Downloading & installation :- 
 -------------------------------------
     
 downloading sql server :- 
 -----------------------------------

 https://www.microsoft.com/en-in/sql-server/sql-server-downloads

 step by step installation of sql server 2022 :- 
 ---------------------------------------------------------

 https://www.sqlshack.com/how-to-install-sql-server-developer-edition/

 download ssms :- 
 --------------------------

 https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver16

Creating new DB
===============
 After loggin
 >Right click on Databases
  >New Database 
   > (two files are created, one is data file .MDF and one is log file .LDF )

 To find it in explorer (to find files in your system)
 ----------------------
 >Programfiles
  >Microsoft SQL Server
   >MSSQL 15.MSSQLSERVER
    >MSSQL
     >DATA
      >(your created DB)

Datatypes
=========
 >CHAR
  >ASCII // char/varchar allows ascii characters (256 characters) that includes a-z, A-Z, 0-9, special characters, i.e., char/varchar allows alphanumeric
   Examples: PANNO CHAR(10), VEHNO CHAR(10), EMAIL VARCHAR(20)

   >char //allows character data upto 8000 characters,
    recommended for fixed length character columns. 
    Example: NAME CHAR(10) here name can be upto 10 characters,
    in char data type extra bytes are wasted, 
    so char is not recommended for variable length fields 
    and is recommended for fixed length fields.
    Example: GENDER CHAR(1) M F , STATE_CODE CHAR(2) AP TS MH, COUNTRY_CODE CHAR(3) IND USA 
               
   >varchar //for variable length use varchar, allows character data upto 8000.
    Example: NAME VARCHAR(10) SACHIN here extra bytes i.e., 4 bytes are released and 
    allocated to other data

   >varchar(max) //to store more than 8000 characters use varchar(max), upto 2GB, 

  >UNICODE // allows unicode characters (65536 characters),
   that includes characters of diff languages.
   >nchar
   >nvarchar
   >nvarchar(max)

 >INTEGER // allows numbers without decimal part
   >tinyint // 1 byte, value between 0 to 255, Examples: AGE
   >smallint // 2 bytes, value between -32768 to 32768, Examples: EMPID
   >int // 4 bytes, value between -2147483648 to 2147483647
   >bigint // 8 bytes, valid number between -9223372036854775808 to 9223372036854775807

   >numberic(p) // allows numbers upto 38 digits, Examples: EMPID NUMERIC(4) here maximum 
    four digits are allowed like 10, 100, 1000, 2000 but 10000 which is 5 characters not allowed
    AADHARNO NUMERIC(12), ACCNO NUMERIC(13), MOBILE NUMERIC(10)

 >FLOAT
   >numeric(p,s) or decimal(p,s) // allows numbers with decimal (float).
    here P means precision that is total number of digits, 
    S means scale that is number of digits after decimal.
    Examples: SAlARY NUMERIC(7,2) like 10000.50 is valid 500000.60 is invalid, 

 >CURRENCY // used for fields related to money
   >smallmoney // 4 bytes, range is -214748.3648 to 214748.3647
   >money // 8 bytes, range is -922337203685477.5808 to 922337203685477.5807
   Exmaples: SAL SMALLMONEY, BAL MONEY

 >DATE 
   >date // only date
   >time // only time
   >datetime // allows date and time
  Defalut date format for SQL Server is YYYY-MM-DD
  Default time format for SQL Server is HH:MM:SS
  Example: DOB DATE, LOGIN TIME, TXNDT DATETIME gives like 2023-05-11 9:30:00

 >BINARY // allows mutimedia objects like audio, video, images
   >binary // allows upto 8000 bytes
   >varbinary // allows upto 8000 bytes
   >varbinary(max) // allows upto 2GB
  Example: photo BINARY(1000) here 1000 bytes allocated for photo and extra bytes are wasted.
  photo VARBINARY(1000) here extra bytes are released
 

   
To Work with Database
=====================
 >Right click on Databases
  >New Querry // Querry window opens

Creating TABLE 
==============
 > Tablename should start with alphabet, no spaces, only _ $ # are allowed,
   can be upto 128 characters, can have 1024 columns, unlimited rows
   Examples: 123EMPID invalid, EMP 123 INVALID, EMP*123 INVALID, EMP_123 VALID

 CREATE TABLE EMP
 (
 EMPID SMALLINT,
 ENAME VARCHAR(10),
 JOB VARCHAR(10),
 SAL SMALLMONEY,
 HIREDATE DATE,
 DNO TINYINT
 )

 > To check exiting Datatypes
   > SP_HELP

To Display table information
============================
 > SELECT * FROM <tablename> 
   > here from above table its SELECT * FROM EMP

Inserting Date into table
=========================
 > "INSERT" command for inserting data
   > we can insert single row or multiple rows

   > Inserting single row
     --------------------
    > INSERT INTO <TABLENAME> VALUES(V1, V2, V3, V4, V5, V6,.....)
    Examples:
     > INSERT INTO EMP VALUES(100,'SACHIN','CLERK',5000,'2023-05-11',10)
     > INSERT INTO EMP VALUES(101,'VIJAY','ANALYST',8000,getdate(),20) // getdate() returns that current days date

   > Inserting multiple rows
     -----------------------
     > INSERT INTO EMP VALUES(102,'PHANI','MANAGER',9000,'2019-10-05',30),(103,'SINDHU','ANALYST',7000,'2021-04-20',20)

   > Inserting blanks 'null' values (empty) // not equal to 0 or space
     --------------------------------------
     > Nulls can be inserted in two ways
     > Method 1: INSERT INTO EMP VALUES(104,'KUMAR',null,3000,'2020-02-15',null)
     > Method 2: INSERT INTO EMP(EMPID,ENAME,SAL,HIREDATE) VALUES(105,'JAMES',5000,getdate()) // remaining fields job,dno filled with nulls



120523

 Operators in SQL Server
 =======================

 + - * / % for calculation
 gives value as output

 Relational operators in SQL Server
 ==================================

 => > >= < <= = <> or !=
 gives True/False as output

 10 > 5 True
 10 < 5 False
 10 = 5 False
 10 <> 5 True ~ 10 != 5 True

 Logical Operators in SQL Server
 ===============================

 AND OR NOT

 Special Operators in SQL Server
 ===============================

 BETWEEN
 IN
 LIKE
 IS
 ANY
 ALL
 EXITS

 Set Operators in SQL Server
 ===========================

 UNION
 UNION ALL
 INTERSECT
 EXCEPT

 Display Data in SQL Server
 ==========================
 
 > "SELECT" command is used to display data from the table.

 syn: SELECT <col/*> FROM <tabname>; // this whole statement is called querry or command and SELECT and FROM  are called clauses

 SQL = English
 QUERIES = Sentences
 CLAUSES = Words

 FROM clause -> specify tablename
 SELECT clause -> specify column names
 * -> all columns

 > Display employee names and salaries/hiredate/dno
 SELECT ENAME,SAL FROM EMP
 SELECT ENAME,HIREDATE FROM EMP
 SELECT ENAME,DNO FROM EMP

 > Display all the data from EMP
   Syntax:
     SELECT * FROM EMP //shows all the data

 > WHERE caluse: ( Display specific )
   ===============
   Used to access specific row/rows based on a condition

 SELECT columns
 FROM tabname
 WHERE condition

 conditions: ( made of relational operators )
  COLNAME OP VALUE
   > OP is any relational operator like > >= < <= = <>
   > if cond is true row is selected
   > if cond is false row is not selected
 Examples:
 ---------
  Display employee details whose id = 102
  > SELECT * FROM EMP WHERE EMPID=102 // goes every row and checks true or false and shows all the datails because '*'
  > SELECT ENAME FROM EMP WHERE EMPID=102 //only name will be shown here 
  Display employee details whose name = 'Kumar'
  > SELECT * FROM EMP WHERE ENAME = 'Kumar' // '' mandatory to display sting
  Display employee details who earn more then 5000
  > SELECT * FROM EMP WHERE SAL > 5000
  Display employees joined after 2020
  > SELECT * FROM EMP WHERE HIREDATE > 2020 // date is incompatable with number
  > SELECT * FROM EMP WHERE HIREDATE > '2020-12-31' // Hiredate date type is compated with '2020-12-31' which is also date type
  Display employees joined before 2020
  > SELECT * FROM EMP WHERE HIREDATE < '2020-01-01'
  Display employees not working for Dno 10
  > SELECT * FROM EMP WHERE DNO <> 10

 Adding multiple condtions to single querry
 Compound condtion:
 ==================
 Multilple condtions combined with AND / OR operators is called compound condtion.
 > WHERE COND1 AND/OR COND2 
 Examples:
 ---------
  > WHERE CATEGORY = 'MOBILES' AND PRICE < 20000 // only mobiles under 20000
  > WHERE CATEGORY = 'MOBILES' OR PRICE < 20000 // any product that is under 20000, satisfying one condtion is enough
  Display Employee details whose id = 100, 103, 105
  > SELECT * FROM EMP WHERE EMPID = 100 OR EMPID = 103 OR EMPID = 105
  Display employees working as clerk, analyst
  > SELECT * FROM EMP WHERE JOB = 'CLERK' OR JOB = 'ANALYST'
  Display employees working as analyst beloging to 20th Dept
  > SELECT * FROM EMP WHERE JOB = 'ANALYST' AND DNO = '20'
  Display employees earning >5000 and <10000
  > SELECT * FROM EMP WHERE SAL > 5000 AND SAL < 10000
  Display employees joined in 2020
  > SELECT * FROM EMP WHERE HIREDATE >= '2020-01-01' AND HIREDATE <= '2020-12-31'
  Display employees working as clerk, analyst and earning more than 5000
  > SELECT * FROM EMP WHERE JOB = 'CLERK' OR JOB = 'ANALYST' AND SAL > 5000 // here JOB = 'ANALYST' AND SAL = 5000 are compared first i.e AND is prioritized and then it'll compare with JOB = 'CLERK'
  > SELECT * FROM EMP WHERE ( JOB = 'CLERK' OR JOB = 'ANALYST' ) AND SAL > 5000 // () to force comparision
    
130523

  IN Operator
  ===========
   >Use IN operator for comparision with list.
    >List is like 10, 20, 30, 40...
   >Use IN operator for "=" comparision with multiple values.
    > WHERE COLNAME = V1,V2,V3... //is invalid, = cannot be used with multiple values
    > WHERE COLNAME IN(V1,V2,V3...) //is valid, if you want to use = with multiple values

    >Display employees whose id = 100,103,105
      > SELECT * FROM EMP WHERE EMPID IN (100,103,105) //Old WHERE EMPID = 100 OR EMPID = 103 OR EMPID =105
    >Display employees working as clerk, manger
     > SELECT * FROM EMP WHERE JOB IN ('CLERK', 'MANAGER')
    >Display employees not working for deptno 10,20
     > SELECT * FROM EMP WHERE DNO NOT IN (10,20)

  WHERE Operator
  ==============
   >Use BETWEEN operator for comeparision with range
    >like 10 to 50 is called range ( all the values between 10 and 50 are included i.e., 10,11,12,.....48,49,50)
    > WHERE COLNAME BETWEEN V1 AND V2 // is equivalent to COL>=V1 AND COL<=V2

    >Display the employees earning between 5000 and 10000
     > SELECT * FROM EMP WHERE SAL BETWEEN 5000 AND 10000 //always use BETWEEN with lower limit and Upper limit
    >Display the employees joined in 2020 year
     > SELECT * FROM EMP WHERE HIREDATE BETWEEN '2020-01-01' AND '2020-12-31'
    >Display the employees not joined in 2020 year
     > SELECT * FROM EMP WHERE HIREDATE NOT BETWEEN '2020-01-01' AND '2020-12-31'
    >Display the employees working as Clerk, manager and earning between 5000 and 10000 and joined in 2019 and not working for deptno 10,20
     > SELECT * FROM EMP WHERE JOB IN ('CLERK', 'MANAGER') AND SAL BETWEEN 5000 AND 10000 AND HIREDATE BETWEEN '2019-01-01' AND '2019-12-31' AND DNO NOT IN (10,20)
    
    PRODUCTS
    PRODID PNAME PRICE CATEGORY BRAND
    
    >Display list of Samsung, Redmi, Realme mobile phones between 10000 and 20000
     > SELECT * FROM PRODUCTS WHERE CATEGORY = 'MOBILES' AND BRAND IN ('SAMSUNG', 'REDMI', 'REALME') AND PRICE BETWEEN 10000 AND 20000
    
    CUSTOMERS
    CID NAME CITY AGE GENDER

    >Display the list of male customers staying in HYD, MUM, DEL aged between 20 and 30
     > SELECT * FROM CUSTOMERS WHERE GENDER = 'MALE' AND CITY IN ('HYD', 'MUM', 'DEL') AND AGE BETWEEN 20 AND 30

  LIKE Operator
  =============

   >Use LIKE operator for comparision of patterns
    > WHERE COLNAME LIKE 'PATTERN'
   >Pattern contains alphabets, digits, wildcard characters

   >Wildcard characters
    --------------------
    > % => 0 or many characters
    > _ => exactly 1 characters

    >Display employees with name starting with 'S' // remaining characters we don't know
     > SELECT * FROM EMP WHRE ENAME LIKE 'S%'
    >Display employees with name ending with 'S'
     > SELECT * FROM EMP WHERE ENAME LIKE '%S'
    >Display employees with name containing 'A'
     > SELECT * FROM EMP WHERE ENAME LIKE '%A%'
    >Display employees with 'A' is the 3rd character of their name
     > SELECT * FROM EMP WHERE ENAME LIKE '__A%' // two underscores before A
    >Display employees with 'A' is the 3rd character of their name from last 
     > SELECT * FROM EMP WHERE ENAME LIKE '%A__' // two underscores after A
    >Display employees with name containing 4 characters
     > SELECT * FROM EMP WHERE ENAME LIKE '____' // four underscores, each underscore is equal to one character
    >Display employees joined in Feb month
     > SELECT * FROM EMP WHERE HIREDATE LIKE '_____02___' // date format is YYYY-MM-DD , %02% does not give only feb but also take dates like 2002-10-15, 2020-02-10, 2023-01-02 it may be month year or day, by giving _____02___ we're forcing SQL to consider it as month
    >Display employees joined in 2020 year
     > SELECT * FROM EMP WHERE HIREDATE LIKE '2020%' // % replaces -MM-DD or use 6 underscores after 2020

150323

 IS Operator 
 ===========
   > For comparision with NULL/ NOT NULL
     > WHERE COLNAME IS NULL
     > WHERE COLNAME IS NOT NULL // NULL cannot be compared with = , must be compared with IS Operator

     > Display empleyees not assigened to any dept
       > SELECT * FROM EMP WHERE DNO IS NULL
     > Display empleyees not assigened to any job
       > SELECT * FROM EMP WHERE JOB IS NULL
     > Display empleyees who are assigened to any dept
       > SELECT * FROM EMP WHERE DNO IS NOT NULL
 
 Summary:
 --------
   WHERE COLNAME IN (V1,V2,V3,V4,V5,V6....)
   WHERE COLNAME BETWEEN V1 AND V2
   WHERE COLNAME LIKE 'PATTERN'
   WHERE COLNAME IS NULL

 Examples:

  STUDENT
  SID SNAME S1 S2 S3
  1   A     80 90 70
  2   B     30 60 50

   > Display list of students who are passed
     > SELECT * FROM STUDENT WHERE S1>=35 AND S2>=35 AND S3>=35
   > Display list of students who are failed
     > SELECT * FROM STUDENT WHERE S1<35 OR S2<35 OR S3<35
  
  CREATE INSERTING DATA Another method ( UI Method)
  =============================
    > Select DB ( your created)
     > right click on table
       > new table
         > click save after entering data
         > Table created

    > Right click on table
      > Edit     

 > ALIAS:
  =======
   > Alias means another name
   > Used to change column headings
   > Syntax: COLNAME / EXPRESSION AS <ALIAS>
   > Examples: // In SELECT on column headings and arthematic calculations are allowed
     > Display ENAME ANNUAL SAlARY
       >SELECT ENAME,SAL*12 AS [ANNUAL SALARY] // name should not contain space, keep it in [] / "" to make it exceptional
     > Display a Table named 123 and (A INT, B INT, C INT)
       > CREATE TABLE [123](A INT, B INT, C INT)
     > Display a Table with ENAME SAL DA TAX TOTSAL
       > HRA House Rent Allowance, take it 20% on sal 
       > DA Dearness Allowance, take it 30% on sal
       > TAX is tax, take it as 10% on sal
       > TOTSAL is SAL+HRA+DA-TAX
       > SELECT ENAME,SAL,SAL*0.2 AS HRA,SAL*0.3 AS DA,SAL*0.1 AS TAX,SAL + (SAL*0.2) + (SAL*0.3) - (SAL*0.1) AS TOTSAL FROM EMP

 > ORDER BY Clause:
  =================
   > Used to sort rows based on one or more columns 
     either in ascending or descending order.
   > SELECT columns FROM tabname [WHERE condition] ORDER BY colname ASC/DESC, ...
   > Default order is ASC for descending order use DESC option
   > Examples:
     > Arrange Employee list name wise asc order 
       > SELECT * FROM EMP ORDER BY ENAME ASC 
     > Arrange Employee list salary wise descending order
       > SELECT * FROM EMP ORDER BY SAL DESC
     > Arrange Employee list dept wise ascending order and with in dept sal wise descending
       > SELECT * FROM EMPNO,ENAME,SAL,DEPTNO FROM EMP ORDER BY DEPTNO ASC, SAL DESC

160523
 
 To delete the table
  > DROP TABLE <tablename>

 Examples:
 ---------
  > STUDENT
    SNO SNAME M  P  C
    1   A     80 90 70
    2   B     60 70 50
    3   C     90 80 70
    4   D     90 70 80
   > Arrange student list average wise descending order, m descending order, p descending order
     > SELECT * FROM STUDENTS ORDER BY (M+P+C)/3 DESC,M DESC,P DESC 
     > but to display average in output SELECT *, (M+P+C)/3 AS AVG FROM STUDENTS ORDER BY (M+P+C)/3 DESC,M DESC,P DESC


  > Display empleyees working as Clerk, manager and arrange list sal wise descending orderorder
   > SELECT EMPNO,ENAME,JOB,SAL FROM EMP WHERE JOB IN ('CLERK','MANAGER') ORDER BY SAL DESC
  
  > Note: Nulls are considered as low in sorting
    > like in ascending order nulls are arranged first and viseversa for descending order.

 DISTINCT clause:
 ----------------
   > ELeminates duplicates from select statement output
   > Syntax
     > DISTINCT col
     > DISTINCT col1,dol2,...
     > DISTINCT *

   > Example
     > SELECT DISTINCT JOB FROM EMP ANALYST CLERK MANAGER PRESIDENT SALESMAN
     > SELECT DISTINCT DEPTNO FROM EMP
       > 10
         20
         30
  
 TOP clause:
 -----------
   > To select top N rows of table
   > SELECT TOP <n> colnames/* FROM tablename [WHERE cond] [ORDER BY colnames]

   > Examples
     > Display first 5 rows from EMP table
       > SELECT TOP 5 EMPNO,ENAME,SAL FROM EMP

     > Display TOP 5 highest paid Employees based on salary
       > SELECT TOP 5 EMPNO,ENAME,SAL FROM EMP ORDER BY SAL DESC 
     
     > Display TOP 5 empleyees based on experience
       > SELECT TOP 5 EMPNO,ENAME,SAL,HIREDATE FROM EMP ORDER BY HIREDATE ASC //here ASC means who joined first will come first
     
     > Display TOP 3 Maximum salaries from empleyee list
       > SELECT DISTINCT TOP 3 SAL FROM EMP ORDER BY SAL DESC // DISTINCt is applied to elemenate duplicates

 DML Commands: ( Data Manipulation language)
 ---------------------------------------

   > Lke INSERT UPDATE DELETE MERGE
   > DML commands acts on table data
   > All these operations are auto committed i.e., 'automatically saved'
     > To STOP autp commit execute the following command
       > SET IMPLICIT_TRANSACTIONS ON
     > To Save operations execute COMMIT command //as auto save is off from the above command
     > To cancel operations execute ROLLBACK command
   
   > INSERT
     > To create new row // refer 118 line INSERT at the start 

   > UPDATE command
     > command used to modify data, can update all rows are specific row, 
       can update sigle column or multiple columns

     > Syntax 
        > UPDATE tablename SET colname = value, colname = value,.... WHERE condition

     > Examples:
       > Update all empleyee commision with 500
         > UPDATE EMP SET COMM = 500
       > Update empleyee commision with 500 whose commision is null
         > UPDATE EMP SET COMM = 500 WHERE COMM IS NULL
       > Update commision with Null whose commision is not equal to null
         > UPDATE EMP SET COMM = NULL WHERE COMM IS NOT NULL // null assignment is = and null comparision is 'IS'
       > Update salary with 2000 and commision with 500 whose id = 7369
         > UPDATE EMP SET SAL = 2000, COMM = 500 WHERE EMPNO = 7369
       > Update increment salary by 20% and commision by 10% who working as SALESMAN and joined in 1981 
         > UPDATE EMP SET SAL = SAL + (SAL * 0.2) COMM = COMM + (COMM * 0.1) WHERE JOB = 'SALESMAN' AND HIREDATE LIKE '1981%'

170523

 Examples:
  > PRODUCTS
    prodid pname price category BRAND
   >Increase the price of all samsung, realme, oneplus brand mobile phones by 10%
     > UPDATE PRODUCTS SET PRICE = PRICE + (PIRCE*0.1) WHERE BRAND IN ('SAMSUNG','REALME','ONEPLUS') AND CATEGORY = 'MOBILES'

  DELETE command
  ==============
   > Command used to delete row/rows based on condition
   > We can delete all rows or specific row
   > Syntax 
      > DELETE FROM <tablename> [WHERE condition] // if Where condition is not given all rows are deleted
   > Examples 
     > Delete all rows from EMP table // dont forget to execute 'SET IMPLICIT_TRANSACTIONS ON' and save manually 'COMMIT'
       > DELETE FROM EMP
     > Delete empleyees joined in 1980
       > DELETE FROM EMP WHERE HIREDATE LIKE '1980%'

  DDL commands: ( DATA DEFINITION LANGUAGE)
  =============
   > CREATE ALTER DROP TRUNCATE are called DDL commands
   > All DDL commands acts on table structure (columns, datatype and size)

   ALTER command:
   --------------
    > command used to modify table structure
    > using ALTER command we can 
      > Add columns
      > Drop columns
      > modify columns
        > changing datatype
        > changing size
     Adding columns:
     > syntax 
        > ALTER TABLE <tablename> ADD COLNAME DATATYPE(size), COLNAME DATATYPE(size),...
     > Examples:
       > Add column gender to emp table
         > ALTER TABLE EMP ADD GENDER CHAR(1) // by default new column is filledw with 'NULL'
         > To insert data into new column use update command
          > UPDATE EMP SET GENDER = 'M' WHERE EMPNO = 7499
  
     Dropping columns:
       > ALTER TABLE <tablename> DROP COLUMN COL1, COL2
       > Examples:
       > Drop column gender from EMP table
       > ALTER TABLE EMP DROP COLUMN GENDER
  
     Modify columns:
       > Syntax:
         > ALTER TABLE <tablename> ALTER COLUMN <colname> TYPE(SIZE)
       > Examples:
         > Increase size of ENAME to 20
           > ALTER TABLE EMP ALTER COUMN ENAME VARCHAR(20) // decrease also possible upto the exisiting data size
         > Change data type of EMPNO to INT
           > AKTER TABLE EMP ALTER COLUMN EMPNO INT // ALTER TABLE EMP ALTER COLUMN EMPNO TINYINT gives ERROR as exiting values are bigger for tinyint

   DROP Command:
   -------------
   > Command drops table from DB
   > Drops table structure along with data
   > Syntax:
      > DROP TABLE <tablename>
   > Examples:
     > DROP TABLE EMP
  
   TRUNCATE command:
   ----------------
    > Deletes all data from the table but keeps structure
    > Will empty the table 
    > Releases moemory allocated for table
    > When truncate is executed sql server goes 
      to memory and releases all the pages allocated for the table
      and when pages are released then date stored in the page also deleted
    > Syntax: TRUNCATE TABLE <table name>
    > Examples: TRUNCATE TABLE EMP

   Question: Differetiate between DROP DELETE TRUNCATE
     > DROP deletes table structure with data
     > DELETE/TRUNCATE deletes only data but not structure
     > DELETE VS TRUNCATE
       > DELETE comes under DML , TRUNCATE comes under DDL
       > DELETE can delete specific rows, TRUNCATE cannot delete specific rows
       > Where condition can be used with DELETE, Where condition cannot be used with TRUNCATE
       > DELETE command deletes row by row, TRUNCATE deletes all rows at a time but cannot single row
       > DELETE is slower, TRUNCATE is faster
       > DELETE will not release memory, TRUNCATE will release memory immediately
       > DELETE will not reset identity, TRUNCATE will reset identity
  
   SP_REMANE: ( SP is STORED PROCEDURE)
   -------------------------------------
     > Used to change the tablename and column name
     > Syntax:
       > SP_REMANE '<oldname>', '<newname>'
     > Examples:
        > Rename EMP table to EMPLOYEES table
         > SP_REMANE 'EMP','EMPLOYEES'
        > Rename column commision to bonus
         > SP_REMANE 'EMPLOYEES.COMM','BONUS' // <tablename.columnname> to change column name in the table

180523

 > Built-in Functions in SQL Server:
   =================================
    > A function accepts some inputs performs some calculations and returns one result

    > Types of functions:
      -------------------
       > DATE STRING NUMERIC CONVERSION SPECIAL ANALYTICAL AGGREGATE 

       > DATE Functions:
         > GETDATE():
           > Returns current date, time and milliseconds
             > SELECT GETDATE() returns 2023-05-18 11:26:41.820 

         > DATEPART():
           > Function used to extract part of the date
             > DATEPART(INTERVAL,DATE)
             > Examples:
               > SELECT DATEPART(YY,GETDATE()) returns 2023
               > SELECT DATEPART(MM,GETDATE()) returns 05
               > SELECT DATEPART(DD,GETDATE()) returns 18
               > SELECT DATEPART(DW,GETDATE()) returns 5 // 1 for Sunday .... 7 for Saturday ....
               > SELECT DATEPART(HH,GETDATE()) returns Hours
               > SELECT DATEPART(MI,GETDATE()) returns Minutes
               > SELECT DATEPART(SS,GETDATE()) returns Seconds
               > SELECT DATEPART(Q,GETDATE()) returns Quarter // like 1 Jan- Mar, 2 Apr- Jun, 3 Jul- Sept, 4 Oct- dec
               > SELECT DATEPART(DAYOFYEAR,GETDATE()) returns day in a year
               > SELECT DATEPART(DY,GETDATE()) returns day in a year

               > Display Employees joined in 1980, 1983, 1985
                 >SELECT * FROM EMP WHERE DATEPART(YY,HIREDATE) IN (1980,1983,1985)

               > Display Employees joined in leap year
                 > SELECT * FROM EMP WHERE DATEPART(YY,HIREDATE) % 4 = 0
               
               > Display Employees joined in January, April, December months
                 > SELECT * FROM EMP WHERE DATEPART(MM,HIREDATE) IN (1,4,12)
               
               > Display Employees joined on Sunday
                 > SELECT * FROM EMP WHERE DATEPART(DW,HIREDATE) IN (1)

               > Display Employees joined in 2nd quarter of 1981
                 > SELECT * FROM EMP WHERE DATEPART(YY,HIREDATE) = 1981 AND DATEPART(Q,HIREDATE) = 2
               
         > DATENAME();
           > Used to extract part of the date

           >                  MM                    DW
           > DATEPART          5                     5
           > DATENAME          MAY                   THURSDAY

          > Examples:
             > Display Employee with name and joinday
               > SELECT ENAME, DATENAME(DW,HIREDATE) AS DAY FROM EMP

             > Display day of India's Independence Day
               > SELECT DATENAME(DW,'1947-08-15')
           
         > FORMAT():
           > Used to display dates in different formats
           > FORMAT(DATE,'<format>')
           
           > Examples:
             > SELECT FORMAT(GETDATE(),'dd-MM-yyyy')
             > SELECT FORMAT(GETDATE(),'MM/dd/yyyy')

             > Display the name hiredate, hiredate in MM/DD,YYYY format
               > SELECT ENAME,FORMAT(HIREDATE,'MM/dd/yyyy')AS HIREDATE FROM EMP
             
             > SELECT FORMAT(GETDATE(),'DD-MM-yyyy hh:mm:ss') // can get both date and time with formats

             > Display the list of empleyees joined today
               > SELECT * FROM EMP WHERE HIREDATE = FORMAT(GETDATE(),'yyyy-MM-dd')
         
         > DATEDIFF():
           > Function used to find difference between two dates
           > DATEDIFF(INTERVAL,START DATE, END DATE)

           > Examples:
             > SELECT DATEDIFF(YY,'2022-05-18',GETDATE()) returns 1
             > SELECT DATEDIFF(MM,'2022-05-18',GETDATE()) returns 12
             > SELECT DATEDIFF(DD,'2022-05-18',GETDATE()) returns 365
            
             > Display name amd experience in years
               > SELECT ENAME,DATEDIFF(YY,HIREDATE,GETDATE()) AS EXPERIENCE FROM EMP

             > Display name amd experience in years,months
               > SELECT ENAME,DATEDIFF(MM,HIREDATE,GETDATE())/12 AS YEARS, DATEDIFF(MM,HIREDATE,GETDATE())%12 AS MONTHS FROM EMP

190523

         > DATEADD():
           > Used to add/subtract days, months,years to/from a date.
           > Syntax:
             > DATEADD(INTERVAL, INT, DATE)
           > Examples:
             > Add 10 days to GETDATE()
               > SELECT DATEADD(DD, 10, GERDATE()) gives 2023-05-29 
             > Add 2 months to GETDATE()
               > SELECT DATEADD(MM,2,,GETDATE()) gives 2023-07-19
             > subtract 1 year from GETDATE()
               > SELECT DATEADD(YY,-1,GETDATE()) gives 2022-05-19

             > Scenario:
               > GOLD_RATES
                 DATEID         RATE
                 2020-01-01      ?
                 2020-01-02      ?

                 2023-05-19      ?

               > Display today's gold rate
                 > SELECT * FROM GOLD_RATES WHERE DATEID = FORMAT(GETDATE(),'yyyy-MM-dd')

               > Display yesterday's gold rate
                 > SELECT * FROM GOLD_RATES WHERE DATEID = FORMAT(DATEADD(DD,-1,GETDATE()),'yyyy-MM-dd')

               > Display last month same day gold rate
                 > SELECT * FROM GOLD_RATES WHERE DATEID = FORMAT(DATEADD(MM,-1,GETDATE()),'yyyy-MM-dd')

               > Display last year same day gold rate
                 > SELECT * FROM GOLD_RATES WHERE DATEID = FORMAT(DATEADD(YY,-1,GETDATE()),'yyyy-MM-dd')

               > Display last one month gold rates
                 > SELECT * FROM GOLD_RATES WHERE DATEID BETWEEN DATEADD(MM,-1,GETDATE()) AND GETDATE()

 ----------------------------------------------------------------------------------------------------------------------
 NOTE:
   > SQL Server date stats from 1900-01-01 , 
     > Examples:
       > FIrst date in SQL calender
         > SELECT DATEADD(DD,0,0) gives 1900-01-01
 ----------------------------------------------------------------------------------------------------------------------

          > EOMONTH():
            > Returns last day of the month
            > Syntax:
              > EOMONTH(DATE,INT)
            > Examples:
              > SELECT EOMONTH(GETDATE(),0) gives 2023-05-31
              > SELECT EOMONTH(GETDATE(),1) gives 2023-06-30
              > SELECT EOMONTH(GETDATE(),-1) gives 2023-04-30
              > Display next month first day
              > Display current month first day
              > Display next year first day
              > Display current year first day

       > STRING FUNCTIONS:
        -------------------

         > UPPER():
           > Used to convert string to uppercase
           > Syntax:
             > UPPER(string)
           > Examples:
             > SELECT UPPER('hello') gives HELLO
         
         > LOWER():
           > Used to convert string to lowercase
           > Syntax:
             > LOWER(string)
           > Examples:
             > SELECT LOWER('HELLO') gives hello

             > Display EMPNO ENAME SAL, names in lowercase
               > SELECT EMPNO,LOWER(ENAME) AS ENAME, SAL FROM EMP // SELECT will only display data not modify actual table data

             > Change names to lowercase in table
               > UPDATE EMP SET ENAME = LOWER(ENAME) // UPDATE changes data in table itself
               
         > LEN():
           > Returns string length i.e., no of characters
           > Syntax:
             > LEN(string)
           > Examples:
             > SELECT LEN('hello world') gives 11 characters

             > Display Employee name and length of the name
               > SELECT ENAME, LEN(ENAME) AS LENGTH FROM EMP 
             > Display Employee names containing 4 characters
               > SELECT * FROM EMP WHERE ENAME LIKE '____' // not idel for all scenarios , like 30 characters
               > SELECT * FROM EMP WHERE LEN(ENAME)=4 

         > LEFT()
           > Returns characters starting from left
           > Syntax
             > LEFT(string,LEN)
           > Examples
             > SELECT LEFT('hello world',5) returns 5 characters starting from left side

             > Display empleyee names starting with 's'
               > SELECT * FROM EMP WHERE LEFT(ENAME,1)='s'
         
         > RIGHT()
            > Returns characters starting from right side
            > Syntax
              > RIGHT(string,LEN)
            > Examples
              > SELECT RIGHT('hello world',7) gives o world

              > Display Employee names that ends with 's'
                 > SELECT * FROM EMP WHERE RIGHT(ENAME,1)='s'
              > Display Employee names that start and end with same characters
                 > SELECT * FROM EMP WHERE LEFT(ENAME,1) = RIGHT(ENAME,1)
         
         > SUBSTRING():
           > Returns characters starting from specific position
           > Syntax 
             > SUBSTRING(string,start,len)
           > Examples 
             > SELECT SUBSTRING('hello world',7,4) gives worl
             > SELECT SUBSTRING('hello world',10,3) gives ld
             
             > Scenario:
               > Generate emailids for employees
                 > EMPNO    ENAME     EMAILID
                   7369     Smith      smi736@tcs.com
                   7499     Allen      all749@tcs.com
               > SELECT EMPNO, ENAME, LEFT(ENAME,3) + LEFT(EMPNO,3) + '@tcs.com'AS EMAILID FROM EMP // displays only

               > Add EMAILID in DB
                > Step 1 : Add EMAILID column to EMP table
                   > ALTER TABLE EMP ADD EMAILID VARCHAR(30)
                > Step 2 : Update the column with emailids
                   > UPDATE EMP SET EMAILID = LEFT(ENAME,3) + LEFT(EMPNO,3) + '@tcs.com'

200523

 > CHARINDEX():
   ------------
    > Used to returns position of a character in a string
    > syntax
      > CHARINDEZ(CHAR,STRING,[START]) // START is optional
    > Examples:
      > SELECT CHARINDEX('O','HELLO WELCOME') returns 5 // if characteris retunrs postion, if not retunrs 0
      > SELECT CHARINDEX('X','HELLO WELCOME') returns 0

      > In 'HELLO WELCOME" find position of O starting from 6
        > SELECT CHARINDEX('O','HELLO WELCOME',6) returns 11

      > Assignment
        > CUST
          CID    NAME
          10     SACHIN TENDULKAR
          11     ROHIT SHARMA

          > Display CID FNAME      LNAME
                    10  SACHIN     TENDULAKAR  
            using LEFT RIGHT SUBSTRING CHARINDEX

  > REPLICATE():
    ------------
    > Used to repeat character for  given numboer of times
    > Syntax:
      > REPLICATE(CHAR,LEN)
    > Examples:
      > SELECT REPLICATE('*',5) gives ***** // 5 stars

      > Display salaries as stars
        > SELECT ENAME,REPLICATE('*',LEN(SAL)) AS SAL FROM EMP

      > Scenario
        > ACCOUNTS 
          ACCNO               ACTYPE    BAL
          1234567892          S         10000
         > Display 'your a/c no XXXX8962 debited _____' // XXXX in place of number 
            > REPLICATE('X',4) + RIGHT(ACCNO,4)

  > REPLACE():
   -----------
   > Used to replacee one string with another string
   > Syntax:
     > REPLACE(str1,str2,str3) returns in str1, str2 replaced with str3
   > Examples:
     > Replace 'ell' with 'abc' in 'hello'
       > SELECT REPLACE('hello','ell','abc') returns 'habco'
     > Replace 'l' with 'abc' in 'hello'
       > SELECT REPLACE('hello','l','abc') returns 'heabcabco'
     > Replace 'elo' with 'abc' in 'hello'
       > SELECT REPLACE('hello','elo','abc') returns 'hello' // 'elo' is not there in string so not replaced
     > Removing unwanted characters, like '@' here 
       > SELECT REPLACE('@@he@@ll@@o@@','@','') gives 'hello' // '' refers null
     > Remove only last ',' in " a,b,c,d,c,e, "
       > 

  > STUFF();
    -------
    > Also similar to replace i.e., used to replace one string with another string
    > Based on start and length
    > Syntax:
       > STUFF(string1,start,length,string2)
    > Examples:
       > Replace 3 characters with 'ABC' starting from 10th character in 'HELLO WELCOME'
         > SELECT STUFF('HELLO WELCOME',10,3,'ABC') gives 'HELLO WELABC'
       > SELECT STUFF('A,B,C,D,',8,1,") gives A,B,C,D

  > TRANSLATE():
    ------------
    > Used to translate one character to another character.
    > Translation cannot be null like SELECT TRANSLATE('HELLO','ELO','') gives ERROR
    > Syntax:
      > TRANSLATE(str1,str2,str3)
    > Examples:
      > SELECT TRANSLATE('HELLO','ELO','ABC') gives 'HABBC' // here E to A, L to B, O to C

    > Note: TRANSLATE function can be used to encrypt data i.e., changing plain text to cipher text
      > Examples:
        > Encrypt Salaries of EMP table
          > SELECT ENAME,TRANSLATE(SAL,'0123456789.','$bT*k@G^#%&') AS SAL FROM EMP
        
        > Remove all the special characters from '@#HE%$LL&^O*@'
          > SELECT  REPLACE (TRANSLATE('@#HE%$LL&^O*@','@#%$&^*','*******'),'*','')  // first translate all the special characters to '*'s, then make it as input to replace
            > Stepl: **HE**LL**O*
            > Step2: HELLO

 > Numeric finctions:
   ===================
   > ABS(): retunrs absolute value
     > Syntax: ABS(NUMBER)
     > Examples:
       > SELECT ABS(10) returns 10
       > SELECT ABS(-10) returns 10 // Always returns positive value

   > POWER():
     > Calculates POWER
     > Syntax: POWER(NUM1,num2)
     > Examples:
       > SELECT POWER(3,2) returns 9

   > SQRT():
     > Returns square root
     > Syntax: SQRT(NUM1)
     > Examples: SELECT SQRT(16) returns 4

   > SQUARE():
     > Returns square of a number
     > Syntax: SQUARE(NUM1)
     > Examples: SELECT SQUARE(5) returns 25
   
   > SIGN():
     > To check whether given number is positive or negative
     > Syntax: SIGN(NUM1)
     > Examples:
        > SELECT SIGN(10) returns 1
        > SELECT SIGN(-10) returns -1
        > SELECT SIGN(0) returns 0

   > Rounding number:
    ------------------
    > ROUND CEILING FLOOR are 3 functions available for Rounding numbers
    
220523

    > ROUND():
     > Rounds number to integer or to decimal places 
     > Round function acts according to average 
     > Syntax: Round(number, decimal places)
     > Examples:
       > SELECT ROUND(38.4567,0) gives 38 //here 0 means this number is rounded to integer
         > If number < Avg rounded to lowest
         > If number >= Avg rounded to highest
       > SELECT ROUND(38.4567,2) gives 38.46
       > SELECT ROUND(38.4547,2) gives 38.45
       > SELECT ROUND(326,-2) gives 400 // -2 means rounding to 100s
         > 300----------350----------400
       > SELECT ROUND(326,-1) gives 360 // -1 means rounding to 10s
         > 350-----------355---------360
       > SELECT ROUND(356,-3) gives 0 // -3 means rounding to 1000s
         > 0-------------500---------1000

       > SELECT ROUND(4567,-1),ROUND(4567,-2),ROUND(4567,-3)
         >            4570           4600            5000

    > CEILING():
      > Rounds number always to highest
      > Example:
        > SELECT FLOOR(38.9) gives 38
    
  > Conversion funcitons:
    ---------------------
    > Used to convert one datatype to another datatype
    > There are two fucntions available CAST CONVERT
    
    > CAST():
      > Syntax
        > CAST(SOURCE-EXPR AS TARGETTYPE)
      > Examples:
        > SELECT CAST(10.5 AS INT) gives 10 // 10.5 is converted to integer
        > SELECT CAST(10 AS DECIMAL) gives 10

        > Display employees 'Smith earns 800', 'ALLEN earns 1600' from EMP Table
          > SELECT ENAME + 'ears' + SAL FROM EMP gives ERROR // All must be character type for concatination
          > SELECT ENAME + 'ears' + CAST(SAL AS VARCHAR) FROM EMP

        > Display 'Smith joined on 1980-12-17 as clerk'
          > SELECT ENAME + ' joined on' + CAST(HIREDATE AS VARCHAR) + 'as' + job FROM EMP
    
    > CONVERT():
      > Syntax:
        > CONVERT(target-type,source-expr)
      > Example:
        > SELECT CONVERT(INT,10.5) gives 10
    
     Note: Using convert we can display dates/money in different formats which is not possible in cast 
      > Date styles:
        > CONVERT(VARCHAR,DATE,STYLE-NUMBER) 
        > Examples:
          > SELECT CONVERT(VARCHAR,GETDATE(),101) gives 05/22/2023 // 101 is predefines style number
          > SELECT CONVERT(VARCHAR,GETDATE(),102) gives 2023.05.22 
            > like this predefined Style-number ranges from 100 to 115 
            > Compared to this FORMAT is more felxible
        
          > Display ENAME, HIREDATE as dd-MM-yyyy format
            > SELECT ENAME,CONVERT(VARCHAR,HIREDATE,105) AS HIREDATE FROM EMP
          > DATEADD with CONVERT
            > SELECT DATEADD(DD,5,CONVERT(DATE,'10/05/2023',103)) gives 2023-05-15 // here with CONVERT date is treated as dd/MM/yyy
            > SELECT DATEADD(DD,5,'10-05-2023') gives 2023-10-10 00:00:00.000  // here without CONVERT date is treated as MM/dd/yyy
      
      > Money styles:
        > Syntax:
          > CONVERT(CARCHAR,NONEY,STYLE-NUMBER)
          > SELECT ENAME,CONVERT(VARCHAR,SAL,0) AS SAL FROM EMP
         > Exmaples:  
           > SELECT ENAME,CONVERT(VARCHAR,SAL,0) AS SAL FROM EMP
           > SELECT ENAME,CONVERT(VARCHAR,SAL,1) AS SAL FROM EMP
           > SELECT ENAME,CONVERT(VARCHAR,SAL,2) AS SAL FROM EMP
           > SELECT CONVERT(VARCHAR,CAST(5000 AS MONEY),1) gives 5,000.00
      
  > SPECIAL Functions:
    ------------------
    > ISNULL():
      > Function used to convert null values
      > This is used to skip NULL // as  NULL +-* NULL is NULL
      > Syntax:
        > ISNULL(arg1,arg2)
      > Example:
        > SELECT ISNULL(100,200) gives 100 // as first arg is not equal to null
        > SELECT ISNULL(NULL,200) gives 00 // as first arg is equal to null gives arg2

        > Display Employee salary with commision
          > SELECT ENAME,SAL,COMM,SAL+COMM AS TOTSAL FROM EMP // Emplouyees with NULL commission were gives NULL TOTALSAL
          > SELECT ENAME,SAL,COMM,SAL+ISNULL(COMM,0) AS TOTSAL FROM EMP gives SAL + COMM // NULL is taken as 0

230523

        > Display ENAME SAL COMM TOTSAL, if COMM is NULL display 'No Commission'
          > SELECT ENAME,SAL,ISNULL(CAST(COMM AS VARCHAR),'NO COMM') AS COMM FROM EMP // ISNULL(arg1,arg2) arg2 must be same type as arg1 type
        
  > Analytical functions or window functions:
    =========================================
    > Mainly useed for data analysis
    > Mainly there two functions RANK, DENSE_RANK
      > These both functions are used to find ranks
      > Ranking is always based on columns like SAL,HIREDATE etc
      > For rank functions data must be sorted 
      > Syntax
        > RANK() OVER ( ORDER BY COLNAME ASC/DESC)
        > DENSE_RANK() OVER ( ORDER BY COLNAME ASC/DESC)
      > Examples:
        > RANK() OVER(ORDER BY SAL DESC)
        > RANK() OVER(ORDER BY SAL ASC)
        > Find ranks of the empleyees based on salary and highest paid should get first rank
          > SELECT ENAME,SAL,RANK() OVER(ORDER BY SAL DESC) AS RANK FROM EMP
          > SELECT ENAME,SAL,DENSE_RANK() OVER(ORDER BY SAL DESC) AS RANK FROM EMP
      > Difference between RANK and DENSE_RANK
        > RANK function generate gaps but DENSE_RANK will not generate gaps
        > RANK function ranks may not be in sequence but in DENSE_RANK rank is always in sequence
        > Example
          > SAL       RANK       DENSE_RANK
            5000      1          1
            4000      2          2
            3000      3          3
            3000      3          3
            3000      3          3
            2000      6          4
            2000      6          4
            1000      8          5
        > Display ranks of Emplouyees based on hiredate
          > SELECT ENAME,HIREDATE,DENSE_RANK() OVER (ORDER BY HIREDATE ASC) AS RANK FROM EMP
        > Display ranks of Emplouyees based on salary and if have same salary then rank bansed on hiredate
          > SELECT ENAME,HIREDATE,SAL,DENSE_RANK() OVER (ORDER BY SAL DESC,HIREDATE ASC) AS RANK FROM EMP
      
    > PARTITION BY clause:
      --------------------
      > Used to find ranks within group
        > Display ranks within a department
          > Divide table department wise
          > Apply DENSE_RANK on each department instead of ranking whole table
          > SELECT ENAME,HIREDATE,SAL,DEPT, DENSE_RANK() OVER(PARTITION BY DEPT ORDER BY SAL DESC) AS RANK FROM EMP
    
    > ROW_NUMBER():
      -------------
      > Returns record number
      > Also based on some column
      > Syntax:
        > ROW_NUMBER() OVER(ORDER BY COLNAME ASC/DESC,---)
      > Examples:
        > SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER(ORDER BY SAL DESC) AS RNO FROM EMP
        > SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER(ORDER BY EMPNO ASC) AS RNO FROM EMP
    
    > LAG() & LEAD():
      ---------------
      > LAG(COLNAME,INT) OVER (ORDER BY COLNAME) returns previous value
      > LEAD(COLNAME,INT) OVER (ORDER BY COLNAME) returns next value
      > SELECT EMPNO, ENAME, HIREDATE, SAL, LAG(SAL,1) OVER( ORDER BY HIREDATE ASC) AS PREV_SAL FROM EMP 
      > After how many days employee hired in EMP table
        > SELECT EMPNO, ENAME, HIREDATE, LAG( HIREDATE,1) OVER ( ORDER BY HIREDATE ASC ) AS PREV_HIREDATE FROM EMP
        > SELECT EMPNO, ENAME, HIREDATE, LAG( HIREDATE,1) OVER ( ORDER BY HIREDATE ASC ) AS PREV_HIREDATE, DATEDIFF(DD,LAG(HIREDATE,1) OVER (ORDER BY HIREDATE ASC),HIREDATE) AS DAYS FROM EMP
      > Days between the two employees hiredate in EMP Table
        > SELECT EMPNO, ENAME, HIREDATE, LAG( HIREDATE,1) OVER ( ORDER BY HIREDATE ASC ) AS PREV_HIREDATE, DATEDIFF(DD,LAG(HIREDATE,1) OVER (ORDER BY HIREDATE ASC), HIREDATE) AS GAP FROM EMP
        
240523

 > Aggregate functions:
   --------------------
   > Takes group of rows, returns one value
   > MAX():
     > Returns maximum value
     > Syntax:
       > MAX(arg)
         > Examples:
           > SELECT MAX(SAL) FROM EMP  gives 5000// takes all the values and returns the maximum value
           > SELECT MAX(HIREDATE) FROM EMP gives 1983-01-12
           > SELECT MAX(ENAME) FROM EMP gives WARD
   > MIN()
     > Syntax:
       > MIN(arg)
     > Examples:
       > SELECT MIN(SAL) FROM EMP gives 800// takes all the values and returns the minimum value
   > SUM()
     > Syntax:
       > SUM(arg)
     > Examples:
       > SELECT SUM(SAL) FROM EMP gives 29025// takes all the values and adds them
       > Round total salaries to 100s
         > SELECT ROUND(SUM(SAL),-2) FROM EMP gives 29000.00
       > After rounding to 100s display total salary with 1000 seperator
         > SELECT CONVERT(VARCHAR,ROUND(SUM(SAL),-2),1) FROM EMP gives 29,000.00
       > Display total salary paid to managers
         > SELECT SUM(SAL) FROM EMP WHERE JOB = 'MANAGER' gives 8275
       > Display totol salary including commission
         > SELECT SUM(SAL + ISNULL(COMM,0)) AS TOTSAL FROM EMP gives 31225\
   > AVG()
     > Syntax
       > AVG(arg)
       > Examples:
         > Display average salary of EMP table
           > SELECT AVG(SAL) AS AVGSAL FROM EMP gives 2073.2142
         > Round average salary of EMP table to lowest
           > SELECT FLOOR(AVG(SAL)) AS LOWEST FROM EMP gives 2073
   > NOTE:
     > SUM, AVG, connot be applied on char, date columns, can be applied only on numberic columns
       > SELECT SUM(HIREDATE) FROM EMP gives error
   > COUNT()
     > Returns number of values present in a column
     > Syntax
       > COUNT(arg)
     > Examples
       > Display number of values in EMPNO of EMP Table
         > SELECT COUNT(EMPNO) FROM EMP //  COUNT function ignores NULLS
       > Display numner of rows from EMP Table
         > SELECT COUNT(*) FROM EMP  // here nulls are counted
       > Display number of employees joiend in 1981 year from EMP Table
         > SELECT COUNT(*) FROM EMP WHERE DATEPART(YY,HIREDATE) = 1981 gives 10 
       > Display employees joind on Sunday from EMP Table 
         > SELECT COUNT(*) FROM EMP WHERE DATENAME(DW,HIREDATE) = 'SUNDAY' gives 1
       > Display number of employees joind in 2nd querter of 1981 from EMP Table
         > SELECT COUNT(*) FROM EMP WHERE DATEPART(YY,HIREDATE) = 1981 AND DATEPART(Q,HIREDATE) = 2 gives 3
   > Note: Aggregate function are not allowed in WHERE clause and are allowed in  SELECT, HAVING clauses
  
  > CASE statement:
    ---------------
    > Similar to switch case
    > Used to implement if-then-else
    > Used to return values based on condition
    > Case statements are of two Types
      > Simple case , Searched case
    > SIMPLE case
      > When conditions based on '=' operator
      > Syntax
        > CASE COLNAME WHEN value1 THEN RETURN expr1 WHEN value2 THEN RETURN expr2 .... [ELSE RETURN expr] END
      > Examples:
        > Display ENAME and DNAME like 
          IF DEPTNO = 10 DISPLAY ACCOUNTS   
                      20         RESEARCH
                      30         SALES
          > SELECT ENAME,DEPT, CASE DEPT WHEN 10 THEN 'ACCOUNTS' WHEN 20 THEN 'RESEARCH' WHEN 30 THEN 'SALES' ELSE 'UNKNOWN' END AS DNAME FROM EMP
        > Update Employee salaries with Increment as follows
          if job = CLERK incr sal by 10%
                   SALESMAN          15%
                   MANAGER           20%
                   OTHERS            5%
          > UPDATE EMP SET SAL = CASE JOB WHEN 'CLERK' THEN SAL + (SAL*0.1) WHEN 'SALEMAN' THEN SAL + (SAL*0.15) WHEN 'MANAGER' THEN SAL + (SAL*0.2) ELSE SAL + (SAL*0.05) END 

250523

    > Searched case
      > When conditions not based on '=' operator
      > Syntax
        > CASE WHEN cond1 THEN RETURN expr1 WHEN cond2 THEN RETURN expr2 ..... [ELSE RETURN expr] END
      > Examples:
        > Display ENAME SAL SALRANGE
          IF SAL > 3000 display HISAL
             SAL < 3000 display LOSAL
             SAL = 3000 display AVGSAL
          > SELECT ENAME, SAL, CASE WHEN SAL > 3000 THEN 'HISAL' WHEN SAL < 3000 THEN 'LOSAL' ELSE 'AVGSAL' END AS SALRANGE FROM EMP 
        > Display SNO TOTAL AVG RESULT from 
          STUDENT 
          SNO   SNAME   S1  S2  S3
          1     A       80  90  70
          2     B       30  60  50
          > SELECT SNO, S1 + S2 + S3 AS TOTAL, (S1 + S2 + S3)/3 AS AVG, CASE WHEN S1 >= 35 AND S2 >= 35 AND S3 >= 35 THEN 'PASS' ELSE 'FAIL' END AS RESULT FROM STUDENT
          > CASE statement with in sum fucntion
            > SELECT SUM(CASE JOB WHEN 'CLERK' THEN SAL END) AS CLERK, SUM(CASE JOB WHEN 'MANAGER' THEN SAL END) AS MAMNAGR FROM EMP
          > Department wise total salary
            > Group by clause can be used 

      > GROUP BY clause:
        > Used to group rows based on one or more columsn to calculate min, max, sum, avg, count for each group
        > GROUP BY converts detailed data into summarized data which is useful for anlysis
        > To calculate total salary of job wise, department wise....
        > Syntax
          > SELECT columns FROM tabname [WHERE cond] GROUP BY colname [JAVING cong] [ORDER BY colname ASC/SESC]
          > Execution order
            > FROM WHERE GROUP BY HAVING SELECT ORDER BY 
        > Examples:
          > To calculate department wise total salary
            > first gorup records based on salary then calculate sum(sal) for each department
            > SELECT DEPT, SUM(SAL) AS TOTSAL FROM EMP GROUP BY DEPT
          > Display Job wise number of employees joined
            > SELECT JOB, COUNT(*) AS CNT FROM EMP GROUP BY JOB
          > Display Year wise number of employees joined
            > SELECT DATEPART(YY,HIREDATE) AS YEAR, COUNT(*) AS CNT FROM EMP GROUP BY DATEPART (YY,HIREDATE)
          > Display Day wise number of employees joined
            > SELECT DATEPART(DW,HIREDATE) AS DAY, COUNT(*) AS CNT FROM EMP GROUP BY DATEPART (DW,HIREDATE)
          > Display Salary range for employees in EMP table
            0-2000 2001-4000 >4000
            > SELECT CASE
             WHEN SAL BETWEEN 0 AND 2000 THEN '0-2000' 
             WHEN SAL BETWEEN 2001 AND 4000 THEN '0-4000' 
             WHEN SAL>4000 THEN '> 4000'
             END AS SALRANGE, COUNT(*) AS CNT
             FROM EMP 
             GROUP BY CASE 
             WHEN SAL BETWEEN 0 AND 2000 THEN '0-2000' 
             WHEN SAL BETWEEN 2001 AND 4000 THEN '0-4000' 
             WHEN SAL>4000 THEN '> 4000'  
             END
                 
260523

          > Display number of joined in each month of year 1981
            > SELECT DATENAME(MM,HIREDATE) WHERE DATEPART(YY,HIREDATE) = 1981 GROUP BY DATENAME(MM,HIREDATE)
          > Display employees having more than 3 employees in EMP table
            > SELECT DEPT, COUNT(*) AS CNT FROM EMP WHERE COUNT(*) > 3 GROUP BY DEPT gives error
              > Above querry returns error as sql server cannot calculate dept wise count before group by and it can calculate only after group by, so apply the condition COUNT(*) > 3 after group by using HAVING clause
              > SELECT DEPT,COUNT(*) AS CNT FROM EMP GROUP BY DEPT HAVING COUNT(*) > 3
    
      > WHERE VS HAVING :
        > WHERE                                        HAVING
          > Selects specific rows                      > Select specific group
          > conditions applied before group by         > conditions applied after group by
          > use WHERE clause if cond doesn't contain   > use HAVING clause if cond contains
            aggregate funtion                            aggregate function
      > Display number of employees for each job where job = CLERK,MANAGER and NO. of employees > 3
        > SELECT JOB,COUNT(*) AS CNT FROM EMP WHERE JOB IN ('CLERK','MANAGER') GROUP BY JOB HAVING COUNT(*) > 3
        > PERSONS
          AADHARNO   NAME   AGE   GENDER  ADDR  CITY  STATE
          > Display southern states having more than 5 cr population
          > SELECT STATE,COUNT(*) FROM PERSONS WHERE STATE IN ('AP,TS,KA,KL,TN') GROUP BY STATE HAVING COUNT(*) > 5000000

      > Goruping based on Multiple columns
        ----------------------------------
        > Display Dept wise and with in dept job wise total salary
          > SELECT DEPT,JOB,SUM(SAL) AS TOTSAL FROM EMP GROUP BY DEPT,JOB ORDER BY DEPT ASC
        > Questions:
          >  PERSONS
          AADHARNO   NAME   AGE   GENDER  ADDR  CITY  STATE
           > Display state wise population
           > Display gender wise population
           > Display age group wise population
           > Display state wise and with in state gender wise population
          
          > SALES
            DATEID     PRODID  CUSTID  QTY  AMOUNT
            2020-01-01  100    10      1    2000
            

            2023-05-26  127    11      1     3000
            > Display year wise total amount
            > Display year wise with in year quarter wise total amount
            > Display quarter wise total amount in the year 2022
              > QRT AMT PRE_QRT %INCR
                1   200  NULL
                2   150  200
                3   250  150
      
      > ROLLUP & CUBE:
        --------------
        > Both functions are used to display subtotals and grand total
        > Syntax:
          > GROUP BY ROLLUP(col1,col2,...)
          > GROUP BY CUBE(col1,col2,...)
        > ROllUP :
          > Displays subtotals for each group and also displays grand total
          > Examples:
            > SELECT DEPT,JOB,SUM(SAL) AS TOTSAL FROM EMP GROUP BY ROLLUP(DEPT,JOB) ORDER BY DEPT ASC
        > CUBE:
          > Displays subtotals for each group by column ( deptno,job)
          > Example:
            > SELECT DEPT,JOB,SUM(SAL) AS TOTSAL FROM EMP GROUP BY CUBE(DEPT,JOB) ORDER BY DEPT ASC
        
        > GROUPING_ID():
          -----------
          > Function accepts GROUP BY columns and returns subtortal belongs to which group by column
          > Example:
            > GROUPING_ID(DEPT,JOB) returns 1 
              > 1 means subtotal belongs to 1st GROUP BY column
              > 2 means subtotal belongs to 2nf GROUP BY column
              > 3 means grand total

270523

            > SELECT DEPT,JOB,SUM(SAL) AS TOTSAL, CASE GROUPING_ID(DEPT,JOB) WHEN 1 THEN 'Dept Subtotal' WHEN 2 THEN 'Job Subtotal' WHEN 3 THEN 'Grand Total' END AS SUBTOTRAL FROM EMP GROUP BY CUBE(DEPT,JOB) ORDER BY DEPT,JOB
 
 Note: Visit Kaggle.com for data sources examples
         > Datasets
           > Select desired Datasets
             > download .csv file // Comma Seperated Value .csv
        To load .csv file in your DB
        > Right click on your DB
          > Tasks
            > Import Data
            > SQL Server Import and Export Wizard
              > Data Source : Flat file // it's .csv file
              > File name: Select your downloaded .csv file
            > Specify where to copy data to
              > Destination : SQL Server
              > Authentication :
                > Username : SACHIN
                > Password : 123

        > To view all the exiting tables in DB
          > SELECT * FROM INFORMATION_SCHEMA.TABLES
        > To ramane table 
          > SP_RENAME 'existing table name', 'required change name'

  > Examples :  
    > Total samples by state wise from states table
      > SELECT STATE,SUM(CAST(TOTALSAMPLES AS BIGINT)) AS TOTSAL FROM COVID GROUP BY STATE
    > Statewise how many samples collected and also positives and negateives
      > SELECT STATE, SUM(CAST(TOTALSAMPLES AS BIGINT)) AS TOTAL, SUM(CAST(NEGATIVE AS BIGINT)) AS NEG, SUM(CAST(POSITIVE AS BIGINT)) AS POSIT FROM COVID GROUP BY STATE ORDER BY STATE ASC
    > Display only Talengana and Andhra Pradesh
      > SELECT STATE, SUM(CAST(TOTALSAMPLES AS BIGINT)) AS TOTAL, SUM(CAST(NEGATIVE AS BIGINT)) AS NEG, SUM(CAST(POSITIVE AS BIGINT)) AS POSIT FROM COVID WHERE STATE IN ('Andhra Pradesh','Telangana') GROUP BY STATE ORDER BY STATE ASC
    > Also group by date year
      > SELECT DATEPART(YY,CONVERT(DATE,DATE,105)) AS YEAR,SUM(CAST(TOTALSAMPLES AS BIGINT)) AS TOTAL, SUM(CAST(NEGATIVE AS BIGINT)) AS NEG, SUM(CAST(POSITIVE AS BIGINT)) AS POSIT FROM COVID WHERE STATE IN ('Andhra Pradesh','Telangana') GROUP BY STATE, DATEPART(YY,CONVERT(DATE,DATE,105)) ORDER BY STATE ASC 

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 > Integrity constraints:
   ======================
   > To maintain data quality
   > Used to prevent users from entering invalid data
   > Used to enforce rules like minimum balance must be 1000
   > SQL Server supports the following integrity constraints
     > NOT NULL
     > UNIQUE
     > PRIMARY KEY
     > CHECK 
     > FOREIGN KEY
     > DEFAULT
   > Above constraints are decalered in two ways
     > Column level
     > Table level
   > Column level:
     -------------
     > If constraints are decalred immediately after declaring column then it is called column level
     > Syntax:
       > CREATE TABLE <tablename> ( COLNAME DATETYPE(SIZE) CONSTRAINT,COLNAME DATETYPE(SIZE) CONSTRAINT.....)
     
     > NOT NULL:
       > NOT NULL doesn't accept NULL values
       > A column declared with NOT NULL is Mandatory column
       > Example
         > CREATE TABLE EMP11 (EMPID INT,ENAME VARCHAR(10) NOT NULL)
         > Testing
           > INSERT INTO EMP VALUE(100,NULL) gives error
           > INSERT INTO EMP VALUE(100,'SACHIN') gives 1 ROW AFFECTED
           
290523

           > INSER INTO EMP(EMPNO)VALUES(101) gives Error 
     
     > UNIQUE:
       > UNIQUE constraint doesn't accept duplicates
       > Examples:
         > Create table CUST
           > CREATE TABLE CUST(CID INT,CNAME VARCHAR(10) NOT NULL,EMAIL VARCHAR(30) UNIQUE) 
       > Testing:
         > INSERT INTO CUST VALUES( 100, 'A', 'abc@gmail.com')
         > INSERT INTO CUST VALUES( 101, 'B', 'abc@gmail.com') gives ERROR
         > INSERT INTO CUST VALUES( 102, 'C', 'null') gives 1 row effected
         > INSERT INTO CUST VALUES( 103, 'D', 'null') gives error // as nulls treated as same value everywhere
     
     > PRIMARY KEY:
       > Doen't accept duplicates and nulls
       > Combination of unique and not null
       > PRIMARY KEY is combination of UNIQUE and NOT NULL
       > In talbe one column must be there to identify records 
         and into that column duolicates and nulls are not allowed 
         and declare that column as primary key
       > Example
         > CREATE TABLE EMP22(EMPID INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL)
         > Testing
           > INSERT INTO EMP22 VALUES (100,'A')
           > INSERT INTO EMP22 VALUES (100,'B') gives Error // duplicates not allowed
           > INSERT INTO EMP22 VALUES (NULL,'C') gives Error // NULLS are not allowed
       > Note
         > Only one primary key is allowed per table
       > Example
         > CREATE TALBE CUSTS(CID INT PRIMARY KEY, NAME VARCHAR(10) NOT NULL,AADHARNO NUMERIC(12) UNIQUE NOT NULL) // as primary can be used only once use UNIQUE NOT NULL( no commas here ) which acts as primary to all others required
       
     > Difference between PRIMARY key and UNIQUE key
       > Primary doesn't allow nulls but unique allows one null
       > Only single can be declared with Primary key but multiple columns can be decalred with Unique 
     
     > Candidate key: // this is theoritical
       > A field eligible for Primary key is called Candidate key
       > Example:
         > Table for RTA
           > VEHICLES
             VEHNO NAME MODEL COST CHASSISNO BRAND
           > Here Candidate keys are VEHNO and CHASSISNO
           > PRIMARY KEY is VEHNO
           > SECOUNDARY KEY is CHASSISNO
       > While creating table SECOUNDARY keys are declared with UNIQUE NOT NULL
    
     > CHECK constraint:
       > Used when rule based on condition
       > Syntax
         > CHECK(condition)
       > Example:
         > SAL must be minium 3000
         > CREATE TABLE EMP33( EMPID INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, SAL MONEY CHECK(SAL>=3000))
         > Testing
           > INSERT INTO EMP33 VALUES (100,'A',1000) gives Error
           > INSERT INTO EMP33 VALUES (101,'B',5000) gives 1 row effected
           > INSERT INTO EMP33 VALUES (102,'C',NULL) gives 1 row effected
           > CHECK constraint allows NULL
         > GENDER must be 'M','F'
           > GENDER CHAR(1) CHECK(GENDER IN ('M','F'))
         > AMT must be multiple of 100
           > AMT MONEY CHECK(AMT%100=0) 
         > PWD must be min 6 characters
           > PWD VARCHAR(12) CHECK(LEN(PWD)>=6) // LEN(<text>) to check length
         > EMAILID must contain '@' and must be ending with '.com' or '.co' or '.in'
           > EMAILID VARCHAR(30) CHECK(EMAILID LIKE '%@%' AND (EMAILID LIKE '%.com' OR EMAILID LIKE '%.co' OR EMAILID LIKE '%.in'))
     
     > FOREIGN key:
       > Used to establish relationship between two talbes
       > To establish relationship between two talbes talbe PRIMARY key of one talbe and add it as 
         FOREIGN key and declare with references constraint
       > Example
         > DEPT
           DNO DNAME LOC
           10  HR    BLR
           20  IT    HYD
           EMP
           EMPID ENAME SAL  DNO REFERENCES DEPT(DNO)
           1     A     5000 10  
           2     B     6000 20
           3     C     4000 90  is invalid 
           4     D     3000 10
           5     E     2000 NULL
       > Values entered in FOREIGN key column should match values if PRIMARY key column
       > FORERIGN Key allows Duolicates and NULLS
       > Afer Declaring FORIEGN key a relatinship is estb between tables called parent/child relationship
       > PRIMARY key table is parent and FOREIGN key table is child
       > Referring table is child amd refferred table in parent
       > Example
          CREATE TABLE DEPT55(DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL, LOC VARCHAR(3) CHECK(LOC IN ('HYD','BLR','MUM','DEL')))
          INSERT INTO DEPT55 VALUES(10,'HR','HYD'),(20,'IT','BLR')
          CREATE TALBE EMP55( EMPID INT PRIMARY KEY, EMANE VARCHAR(10) NOT NULL,SAL MONEY CHECK(SAL>=3000), DNO INT REFERENCES DEPT55(DNO))
          > Testing:
            INSERT INTO EMP55 VALUE(1,'A',5000,10)
            INSERT INTO EMP55 VALUES(2,'B',4000,90)
            INSERT INTO EMP55 VALUES(3,'C',3000,10)
            INSERT INTO EMP55 VALUES(4,'D',4000,NULL)

300523

       > Assignment
         > Create table with given rules
           > ACCOUNTS
             ACCNO  ACTTYPE  balance
           > Rules:
             > Accno should not be dubplicate and null
             > Acttype must be 'S' or 'C'
             > Bal must be min 1000

           > TRANSACTIONS
             TRID TTYPE TDATE TAMT ACCNO
           > Rules
             > TTYPE must be 'W' or 'D'
             > TRID should not be duplicate & null
             > TDATE must be today's date
             > TAMT must ebe multiple of 100
             > ACCNO should match with accounts table accno

    > Relationships types between two tables (parent child)
      ===================
        > One to One (1:1)
        > One to Many (1:m)
        > Many to One (m:1)
        > Many to Many (m:m)

      > By default SQL Server creates One to Many (1:m) relationship between two tables

      > One to One Realtionship (1:1)
        ------------------------
        > To estb between two tables declare foreign key with unique constraint
        > Examples:
          > DEPT 
            DNO DNAME LOC
            10  HR    HYD
            20  IT    BLR
          > MGR
            MGRNO MNAME DNO REFERENCES DEPT(DNO) UNIQUE 
            1     A     10
            2     B     20
          > In the above example one dept is managed by one manger
            and one manager manages exaclty one dept, 
            so relationship between dept and manager is one to one,
            so decalre foreign key with unique constraint.
          
          > CREATE TABLE DEPT ( DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL, LOC VARCHAR(3))
            CREATE TABLE MGR ( MGRNO NUMBER(4) PRIMARY KEY, MNAME VARCHAR(10) NOT NULL, DNO INT REFERENCES DEPT(DNO) UNIQUE)
      
      > Many to Many (m:m) 
        ------------------
        > To estb many to many relationship between two tables create 3rd table
          and in third table take primary keys of both the tables as foreign keys
        > Example:
          > CUST
            CID  NAME  ADDR
            10   A     HYD
            11   B     HYD
            12   C     HYD
          > PRODUCTS
            PRODID  PNAME  PRICE
            100     A       1000
            101     B       2000
            102     C       1500
          > In the above example one cust purchases many products and product purchased by many
            customers, sp relationship between cust & product is many to many, so crete 
            third table and take primary key of both tables ( CID,PRODID) as FOREIGN keys
            > SALES
              DATEID  PRODID  CID  QTY  AMT
              10-     100     10   ?    ?
              10-     100     11   ?    ?
              11-     101     10   ?    ?
            > CREATE TABLE CUST(CID INT PRIMARY KEY, CNAME VARCHAR(10) NOT NULL)
              CREATE TABL E PRODUCTS(PRODID INT PRIMARY KEY,PNAME VARCHAR(10) NOT NULL)
              CREATE TABLE SALES(DATEID INT,PRODID INT REFERENCES PRODUCTS(PRODID),CID INT REFERENCES CUST(CID),QTY INT,AMT MONEY)
             
        > ER DIAGRAM

          ER MODEL     RELATIONAL MODEL

          ENTITIES     TABLES
          ATTRIBUTES   FIELDS
          RELATIONSHIP FOREIGN KEY

          Example: Bank Realtional model for ER Model
           > BANK
             CODE NAME ADDR
           > BRANCH
             BRANCH_ID NAME ADDR CODE(FK)
           > ACCOUNTS
             ACCNO ACTYPE BAL BRANCH_ID(FK)
           > LOANS 
             LOAN_ID LOAD_TYPE AMOUNT BRANCH_ID(FK) CUSTID(FK)
           > CUSTOMERS
             CUSTID NAME PHONE ADDR
        
    > DEFAULT values
      -------
      > A column can be declared with default values as follows
      > While inserting if we skip HIREDATE SQL Server inserts DEFAULT value
      > Example
        > HIREDATE DATE DEFAULT GETDATE()
        > CREATE TABLE EMP44(EMPID INT,ENAME VARCHAR(10),HIREDATE DATE DEFAULT GETDATE())
          INSERT INTO EMP44(EMPID,ENAME) VALUES(100,'A') // here default date is inseted
          INSERT INTO EMP44 VALUES(101,'B','2023-01-01') // here given date is inserted
          INSERT INTO EMP44 VALUES(102,'B',NULL)
          SELECT * FROM EMP44
    
    > TABLE LEVEL
      -----------
      > If constraints are declared after declaring all columns thne it is called table level
      > Syntax
        > CREATE TABLE<tablename>
          (
            COLNAME DATETYPE(SIZE),
            ---------------------,
            ---------------------,
            CONSTRAINT
          )
      > Use TABLE LEVEL for declaring constraints for multiple or combination of columns

    > Declaring check constraints at table level
      ------------------------------------------
      > PRODUCTS
        PRODID PRNAME PRICE MFD_DT      EXP_DT
        100    A      50    2023-05-30  2023-01-01   gives invalid 
        > Rule
          > EXP_DT  > MFD_DT  this must be declared at table level
        > CREATE TABLE PRODUCTS 
         (
          PRODID INT PRIMARY KEY,
          PNAME VARCHAR(10) NOT NULL,
          MFD_DT DATE,
          EXP_DT DATE,
          CHECK (EXP_DT > MFD_DT)
         ) 
         INSERT INTO PRODUCTS VALUES(1,'A',GETDATE(),'2023-01-01') gives error
         INSERT INTO PRODUCTS VALUES(1,'A',GETDATE(),'2023-10-01')

310223

 > Composite Primary key:
   ---------------------
   > In saome tables we may not be able to uniquely identify the records using single column,
     and we need combinations of columns to uniquely identify the records and that combination
     should be declared as Primary Key at table level
   > If combination of columns decalred then it is called Composite Primary key
   > In Composite Primary Key combination should not be dubplicate
   > Example
     > In registrations table SID, CID combinations uniquely identifing the records so declare
       this combination as Primary Key at table level
       > CREATE TABLE STUDENT ( SID INT PRIMARY KEY, SNAME VARCHAR(10) NOT NULL)
         INSERT INTO STUDENT VALUES (1,'A'), (2,'B')
         CREATE TABLE COURSE ( CID INT PRIMARY KEY, CNAME VARCHAR(10) NOT NULL)
         INSERT INTO COURSE VALUES ( 10, '.NET'), (11,'SQL SERVER')
         
         CREATE TABLE REGIESTRATION( SID INT REFERENCES STUDENT(SID), CID INT REFERENCES COURSE(CID), 
         DOR DATE, FEE MONEY, PRIMARY KEY (SID,CID))

         INSERT INTO REGISTRATION VALUES (1,10,GETDATE(),5000)
         INSERT INTO REGISTRATION VALUES (1,11,GETDATE(),5000)
         INSERT INTO REGISTRATION VALUES (2,10,GETDATE(),5000)
         INSERT INTO REGISTRATION VALUES (1,10,GETDATE(),5000) gives Error

     > Assignment 
       > Identify PRimary keys and foreign keys and write create table script
        > CUST                               PRODUCTS
          CID   NAME   ADDR                  PRODID PNAME PRICE
          10                                 100
          11                                 101

          SALES 
          DATEID   PRODID CUSTID  QTY  AMT
          30       100    10      1    2000
          30       101    10      1    1000
          30       101    11      1    2000
          31       100    10      1    2000

 > NOTE: 
   > All constraints can be decalred at table level except NOT NULL
   > A column with UNIQUE constraints can contain NULL value
   > NOT NULL cannot be decalred at Table level
 
 > Adding constraints to existing table
   ------------------------------------
   > 'ALTER' command is used to add constraints to existing table

   > Adding check constraint 
     > Example
       > Adding check constraint with condition sal >= 3000
         > CREATE TABLE EMP88 ( EMPID INT, ENAME VARCHAR(10), SAL MONEY, DNO INT)
         > ALTER TABLE EMP88 ADD CHECK(SAL>=3000)
    > Note 
      > While adding constraint SQL SERVER also validates existing data, if existing date 
        satisfies the condition then constraint is added otherwise not added.
    
 > WITH NOCHECK
   ------------
   > If constraint added with NOCHECK then SQL SERVER will not validate existing date and it validates only
     new data
   > Example
     > ALTER TABLE EMP WITH NOCHECK ADD CHECK(SAL>3000)
 
 > Adding PRIMARY KEY
   ------------------
   > Adding PRIMARY KEY to an exisiting table
   > PRIMARY KEY cannot be added on NULLABLE column // by default all columns are NULLABLE
   > Process
     > Change column to NOT NULL
     > Add PRIMARY KEY 
   > Example:
     > Add PRIMARY KEY to EMPID of EMP88 Table
       > Change column EMPID to NOT NULL
         > ALTER TABLE EMP88 ALTER COLUMN EMPID INT NOT NULL
       > Add PRIMARY KEY
         > ALTER TABLE EMP88 ADD PRIMARY KEY( EMPID )
       > SP_HELP EMP88
 
 > Adding FOREIGN KEY
   ------------------
   > Add FOREIGN KEY to DNO that references DEPT table PRIMARY KEY i.e., DEPTNO
     > CREATE TABLE DEPT
       (DEPTNO INT primary key,
       DNAME VARCHAR(14),
       LOC VARCHAR(13) )

       INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK')
       INSERT INTO DEPT VALUES (20, 'RESEARCH', 'DALLAS')
       INSERT INTO DEPT VALUES (30, 'SALES', 'CHICAGO')
       INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON')

       ALTER TABLE EMP88 
       ADD FOREIGN KEY (DNO) REFERENCES DEPT(DEPTNO)

   > After adding FOREIGN KEY one to many relationship is created
     to establish one to one relationship 
     > Add UNIQUE constraint to DNO
       > ALTER TABLE EMP88 ADD UNIQUE(DNO)

 > Changing from NULL to NOT NULL
   ------------------------------
   > Modify column ENAME to NOT NULL
     > ALTER TABLE EMP88 ALTER COLUMN ENAME VARCHAR(10) NOT NULL

010623

 > DROP constraint
   ---------------
   > Syntax
     > ALTER TABLE <table name> DROP CONSTRAINT <name>
     > Example
       > Drop CHECK constraint in EMP88 table
         > ALTER TABLE EMP88 DROP CONSTRAINT CK__EMP88__SAL__5535A963
       > Drop PRIMARY KEY in DEPT Table
         > ALTER TABLE DEPT DROP CONSTRAINT PK__DEPT__E0EB08D7ACE20F53
   > Note: 
     > PRIMARY KEY constraint camnot be dropped if referenced by some FOREIGN KEY
     > PRIMARY KEY table camnot be dropped if referenced by some FOREIGN KEY
     > PRIMARY KEY table camnot be truncated if referenced by some FOREIGN KEY
 
 > DELETE rules
   ------------
   > ON DELETE NO ACTION (DEFAULT)
   > ON DELETE CASCADE 
   > ON DELETE SET NULL
   > ON DELETE SET DEFAULT
   
   > These rules are decalred with FOREIGN KEY
   > Above rile specifies how child rows are affected if parent rows are deleted

   > ON DELETE NO ACTION 
     > Parent rows cannot be deleted if associatedwith child rows
     > Example
      > CREATE TABLE DEPT66 (DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL)
        INSERT INTO DEPT66 VALUES(10,'HR'), (20,'IT')
        CREATE TABLE EMP66 ( EMPNO INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, DNO INT REFERENCES DEPT66(DNO))
        INSERT INTO EMP66 VALUES(1,'A',10),(2,'B',10)
        DELETE FROM DEPT66 WHERE DNO=10 gives Error
      > Scenario
        > ACCOUNTS
          ACCNO    BAL
          100      100004
          101      200000

          LOANS 
          ID  TYPE AMT  ACCNO REFERENCES
          1   H    30   100
          2   C    10   100
          > Note
            > Account closing is not possible if associated with loans
   
   > ON DELETE CASCADE
     > If parent row is deleted then it is deleted along with child rows
     > Example
       > CREATE TABLE DEPT66 (DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL)
        INSERT INTO DEPT66 VALUES(10,'HR'), (20,'IT')
        CREATE TABLE EMP66 ( EMPNO INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, DNO INT REFERENCES DEPT66(DNO) ON DELETE CASCADE)
        INSERT INTO EMP66 VALUES(1,'A',10),(2,'B',10)
     > Scenario
       > ACCOUNTS 
         ACCNO  BAL
         100    10000

         TRANSACTIONS
         TRID  TTYPE TDATE TAMT ACCNO  REFERENCES ACCOUNTS(ACCNO)
         1     W     ?     2000 100    ON DELETE CASCADE
         2     D     ?     1000 100
        > NOTE
          > When account is closed, along with account delete transactions
   
   > ON DELETE SET NULL
     > If Parent row is deleted then child are not deleted but FOREIGN KEYS are set to null value
     > Example
       > CREATE TABLE DEPT66 (DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL)
        INSERT INTO DEPT66 VALUES(10,'HR'), (20,'IT')
        CREATE TABLE EMP66 ( EMPNO INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, DNO INT REFERENCES DEPT66(DNO) ON DELETE SET NULL)
        INSERT INTO EMP66 VALUES(1,'A',10),(2,'B',10)
        > Testing
          > DELETE FROM DEPT66 WHERE DNO = 10 gives one row affected
            SELECT * FROM EMP66
            EMPNO  ENAME  DNO
            1       A      NULL
            2       B      NULL
       > Scenario
         > PROJECTS
           PROID  NAME   DURATION   COST   CLIENT
           100    A      5 YEARS    500    TATA MOTORS

           EMP
           EMPID  ENAME  SAL  PROID  REFERENCES PROJECTS(PROID)
           1      ....   ...  100    ON DELETE SET NULL
           2      ....   ...  101
           > NOTE 
             > If project is completed set employee's PROID to null
  
   > ON DELETE SET DEFAULT
     > If Parent row is deleted then childs are not deleted but FOREIGN KEY is set to default value
     > Example
       > REATE TABLE DEPT66 (DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL)
        INSERT INTO DEPT66 VALUES(10,'HR'), (20,'IT')
        CREATE TABLE EMP66 ( EMPNO INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, DNO INT DEFAULT 20 REFERENCES DEPT66(DNO) ON DELETE SET DEFAULT)
        INSERT INTO EMP66 VALUES(1,'A',10),(2,'B',10)
        DELETE FROM DEPT66 WHERE DNO=10 gives 1 row effected
        SELECT * FROM EMP66
        EMPNO ENAME DNO
        1     A     20
        2     B     20

 > Summery:
   > Importance of constraints
   > Types of constraints
   > DEcalreing constraints
     > Column level
     > Table level
   > Adding constraints to existing table
   > Delete rules

 > JOINS
  =====
   > JOIN is an operation performed to get data from two or more tables
   > In DB related data may be stored in multiple tables, to gather or to combine
    data stored in multiple tables we need to join those tables
   > Example
     > ORDER talbe and CUSTOMER table joining
   > Types of JOINS
     > INNER JOIN / EQUI JOIN
     > OUTER JOIN
       > LEFT JOI
       > RIGHT JOIN
       > FULL JOIN
     > NON EQUI JOIN
     > SELFT JOIN
     > CROSS JOIN / CARTESIAN JOIN 
    
020623

   > INNER JOIN/EQUI JOIN
     > To perform INNER JOIN between two tables, there must be a common field, name of 
       the commong field need not be same and PRIMARY KEY FOREIGN KEY relationship is 
       not compulsory
     > EQUI JOIN is performed based on the common field with same data type
     > Syntax
       > SELECT column FROM table1 INNER JOIN table2 ON join condition
     > JOIN Condition
       --------------
       > SQL Server join the records of two tables based on given join condition
         > If condition is true records are joined and if false records are not joined
       > Syntax
         > TABLE1.<commonfield> = TABLE2.<commonfield>
       > Example
         > EMP 
           EMPNO  ENAME SAL   DEPTNO
           1      A     5000  10
           2      B     3000  20
           3      C     4000  30
           4      D     2000  40
           5      E     3000  50
         > DEPT 
           DEPTNO DNAME      LOC
           10     ACCOUNTS   NY
           20     RESEARCH   NY
           30     SALES      NY
           40     OPERATIONS NY
         > Display ENAME SAL DNAME LOC
                  ---------- ---------
                     EMP       DEPT
            > SELECT ENAME, SAL, DNAME, LOC FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO
              > A  5000 ACCOUNTS NY
                B  3000 RESEARCH NY
                C  4000 SALES    NY
                D  2000 RESEARCH NY
            > SELECT EMP.ENAME, EMP.SAL, DEPT.DNAME, DEPT.LOC FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO // mentioning table like EMP. DEPT. after SELECT makes it faster to execute
            > SELECT E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC FROM EMP AS E INNER JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO
            > NOTE
              > In join querries decalre table alias and prefix column names with talbe alias for two reasons
                > To avoid ambiguity error
                > for faster execution
              > 
            > Example
              > Display employee details with dept details working at New York location
                > SELECT E>ENAME, D.DNAME, D.LOC FROM EMP AS E INNER JOIN DEPT D ON E.DEPTNO = D>DEPTNO WHERE D.LOC = 'NY'
              > Display order details with custom details
                > SELECT O.*, C.* FROM ORDERS AS O INNSER JOIN CUST AS C ON O.CID = C.CID
              > Display order details with custom details to be delivered today
                > SELECT O.*, C.* FROM ORDERS AS O INNSER JOIN CUST AS C ON O.CID = C.CID
                  WHERE O.DEL_DT = GETDATE()
      
      > Joining more than two table
       -----------------------------
        > Number of join conditions also increase with numbre of talbes
        > To join N talbes N-1 join conditions required
        > syntax
          > SELECT column FROM table1 INNER JOIN table2 ON join condition INNER JOIN table3 ON join condition INNER JOIN table4 ON join condition INNER JOIN table5 ON join condition...
        > Example
          > EMP      DEPT     LOCAITONS    COUNTRIES
            EMPNO    DEPTNO   LOCID        COUNTRY_ID
            ENAME    DNAME    CITY         COUNTRY_NAME
            SAL      LOCID    STATE
            DEPTNO            COUNTRY_ID
            > Display ENAME DNAME CITY STATE COUNTRY_NAME
              > SELECT E.ENAME, 
                       D.DNAME,
                       L.CITY,L.STATE,
                       C.COUNTRY_NAME
                FROM EMP AS E INNER JOIN DEPT AS D 
                       ON E>DEPTNO = D.DEPTNO
                                INNER JOIN LOCATIONS AS L
                       ON D.LOCID = L.LOCID
                                INNER JOIN COUNTRIES AS C 
                       ON L.COUNTRY_ID = C.COUNTRY_ID
    
    > OUTER JOIN
      ----------
      > Inner jkoin returns only matching records , to display unmatched records preform outer join
      > Outer Join is of 3 types
        > LEFT JOIN
        > RIGHT JOIN
        > FULL JOIN

030623

      > LEFT JOIN
        > Returns all rows ( matched + unmatched ) from left side table and matching rows fro mright side table
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E LEFT JOIN  DEPT AS D ON E.DEPTNO = D.DEPTNO
        > Returns all rows from EMP table and matching rows from dept table
          A ACCOUNTS
          B RESEARCH
          C SALES
          D RESEARCH
          E NULL => unmatched rows from EMP
      
      > RIGHT JOIN
        > Returns all rows from right side table matching rows from left side table
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E RIGHT JOIN  DEPT AS D ON E.DEPTNO = D.DEPTNO
            A ACCOUNTS
            B RESEARCH
            C SALES
            D RESEARCH
            NULL OPERATIONS => Unmatched from dept

      > FULL JOIN
        > Returns all the rows from both the tables
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E FULL JOIN  DEPT AS D ON E.DEPTNO = D.DEPTNO
            A ACCOUNTS
            B RESEARCH
            C SALES 
            D RESEARCH
            E NULL  => unmatched from EMP
            NULL OPERATIONS => unmatched from DEPT
    
    > Display Unmatched records:
      --------------------------
      > Left side table
        > syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS LEFT JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO WHERE D.DNAME IS NULL
            E NULL
      > Right side table
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E RIGHT JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO WHERE E.ENAME IS NULL
            NULL OPERATIONS
      > Both the tables
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E FULL JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO WHERE D.DNAME IS NULL OR E.ENANE IS NULL
      
      > Scenario:
        > EMP                       PROJECTS
          EMPID ENAME SAL PROJID    PROJID  NAME DURATION COST CLIENT
          1               100       100
          2               101       101
          3               NULL      102
        > Display employee details with project details
        > Display employee details woth project details and also display employee not assigned to any project
        > Display employee details woth project details and also display projects where no employee assignes to it

 > NON EQUI JOIN
   -------------
   > NON EQUI JOIN is performed between the tables not sharing a common field
   > Example
      > EMP                          SALGRADE
         EMPNO  ENAME  SAL            GRADE  LOSAL  HISAL
         1      A      3000           1      700    1000
         2      B      1500           2      1001   2000
         3      C      2000           3      2001   3000
         4      D      1000           4      3001   4000
         5      E      4000           5      4001   9999
         > Display ENAME SAL     GRADE
                  ---------     -----
                    EMP        SALGRADE
          SELECT E.ENAME, E.SAL, S.GRADE FROM EMP AS E JOIN  SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL 
           A  3000 3 
           B  1500 2
           C  2000 2
           D  1000 1
           E  4000 4
      > Display grade 4 employee list
        > SELECT E.ENAME, E.SAL, S.GRADE FROM EMP AS E JOIN  SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL WHERE S.GRADE = 4         
      > Display ENAME DNAME GRADE ( data belongs to 3 tables EMP DEPT SALGRADE)
        > EMP DEPT INNER JOIN and EMP SALGRADE NON EQUI JOIN
        > SELECT E.ENAME, D.DNAME, S.GRADE FROM EMP AS E INNER JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO JOIN SALGRADE AS S ON E.SAL BETWEEN S.LOSAL AND S.HISAL
          > Steps
            EMP                              SALGRADE
            EMPNO ENAME SAL   DEPTNO         GRADE     LOSAL    HISAL
            1     A     3000  10             1         700      1000
            2     B     1000  20             2         1001     2000
            3     C     4000  30             3         2001     3000
                                             4         3001     4000
            Output is joined with DEPT Table       DEPT
            1 A 3000 3  10                          DEPTNO  DNAME     LOC
            2 B 1000 1  20                          10      ACCOUNTS   
            3 C 4000 4  30                          20      RESEARCH

            Output ( ON E.DPETNO = D.DEPTNO )
            1 A 3000 3 10 accounts
            2 B 1000 1 20 RESEARCH
            3 C 4000 4 30 SALES

            SELECT E.ENANME, D.DNAME, S.GRADE
            A ACCOUNTS 3
            B RESEARCH 1
            C SALES    4

050623

 > SELF JOIN
   ---------
   > Joining a table to itself
   > In self join a record of the table joined with another record of itlsef
   > To perform SELF JOIN the same table should be declared with different alias
   > Syntax
     > FROM EMP AS X JOIN AS Y // same table with different alias
   > Example
     > Display ENAME MGRNAME  
        EMP X                   EMP Y
        EMPNO ENAME MGR         EMPNO ENAME MGR
        1     A     NULL        1     A     NULL
        2     B     1           2     B     1
        3     C     1           3     C     1
        4     D     2           4     D     2
        5     E     3           5     E     3
      > SELECT X.ENAME, Y.ENAME AS MANAGER FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO
        B A
        C A
        D B
        E C
     > Display Emplouyees reporting to blake
       > SELECT X.ENAME, Y.ENAME AS MANAGER FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO WHERE Y.ENAME = 'BLAKE'
     > Display Blake's manager name
       > SELECT X.ENAME, Y.ENAME AS MANAGER FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO WHERE X.ENAME = 'BLAKE'
     > Display Emplouyees earning more than their managers
       > SELECT X.ENAME, X.SAL, Y.ENAME AS MGR, Y.SAL AS MGRSAL FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO WHERE X.SAL > Y.SAL
     > Display employees joined before their manager
       > SELECT X.ENAME, X.HIREDATE, Y.ENAME AS MGR, Y.HIREDATE FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO WHERE X.HIREDATE < Y.HIREDATE
     > Question
       > TEAMS 
         ID  COUNTRY
         1   IND
         2   AUS
         3   ENG
         > Write a querry to display
           IND VS AUS
           IND VS ENG
           IND VS ENG
           TEAMS A      TEAMS B
           ID COUNTRY  ID COUNTRY
           1  IND      1  IND
           2  AUS      2  AUS
           3  ENG      3  ENG
           > CREATE TABLE TEAMS( ID INT, COUNTRY VARCHAR(3))
           > SELECT A.COUNTRY + ' VS ' + B.COUNTRY FROM TEAMS AS A JOIN TEAMS AS B ON A.ID < B.ID
       > Assignmet
         > Display employees earnign same salary
         > Display employees joined on smae day
 
 > CROSS JOIN / CARTESIAN JOIN
   ---------------------------
   > Returns cross product or cartesian product of two tables
   > like
     A = 1,2,
     B = 3,4,
     AXB = (1,3) (1,4) (2,3) (2,4)
   > If cross join preformed between two talbes all the records of first table will be joined with all the records of 2nd table
   > To perform CROSS JOIN JOIN Querry is not required
   > Example
     > SELECT E.ENAME, D.DNAME FROM EMP AS E JOIN DEPT AS D
 
 > JOIN & GROUP BY
   ---------------
   > SELECT D.DNAME, SU<(E.SAL) AS TOTSAL FROM EMP AS E INNER JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO GROUP BY D.DNAME

060623

 > SET OPERATIONS
   --------------
   > UNION 
   > UNION ALL
   > INTERSECT 
   > EXCEPT
   > Explaination
     A = 1,2,3,4
     B = 1,2,5,6
     A UNION B = 1,2,3,4,5,6
     A UNION ALL B = 1,2,3,4,5,6
     A INTERSECT B = 1,2
     A EXCEPT B = 3,4
     B EXCEPT A = 5,6
   > IN SQL Server SET OPERATIONS performed between records ( rows ) return by two querries
   > Syntax:
     > SELECT statement 1 UNION / UNION ALL / INTERSET / MINUS SELECT statement 2
   > Rules
     > No of columns return by both querries must be same
     > Correspoinding columns datatype must be same
   > Example
     > SELECT JOB FROM EMP WHERE DEPT = 30

   > UNION
     > Comnines rows return by tow querries
     > Duplicates are eliminated
     > Result is sorted
     > Syntax
       > SELECT JOB FROM EMO WHERE DEPT = 20
         UNION
         SELECT JOB FROM EMO WHERE DEPT = 30
         > ANALYST
           CLERK
           MANAGER
           SALESMAN

   > UNION VS JOIN
     > UNION comnines rows , JOIN combines columns
     > UNION is horizontal merge, JOIN is vertical merge
     > UNION performed between tow similar structures, JOIN is performed between tow dissimilar structures
     > Example
       > T1 T2
         F1 C1
         1  10
         2  20
         3  30
         > T1 U T2   T1 JOIN T2
           1         1       10
           2         2       20
           3         3       30
           10
           20
           30
       > Scenario
         > EMP_US
           ENO ENAME SAL DNO
           EMP_IND
           ENO ENAME SAL DNO
           DEPT 
           DNO DNAME LOC
           > Display total empleyee list
             > SELECT * FROM EMP_US UNION SELECT * FROM EMP_IND
           > Display employees working at US loc with dept details
             > SELECT E.*, D.* FROM EMP_US AS E INNER JOIN DEPT AS D ON E.DNO = D.DNO
           > Display total employees with dept details
             > SELECT E.*, D.* FROM EMP_US AS E INNER JOIN DEPT AS D ON E.DNO = D.DNO 
               UNION
               SELECT E.*, D.* FROM EMP_IND AS E INNER JOIN DEPT AS D ON E.DNO = D.DNO
   
   > UNION ALL
     > Combines rows
     > Duplicates are not eleminated
     > Result is not sorted
     > Example
       > SELECT JOB FROM EMP WHERE DEPT = 20
         UNION ALL
         SELECT JOB FROM EMP WHERE DEPT = 30

     > UNION vs UNION ALL
       > UNION eleminates duplicates, UNION ALL doesn't
       > UNION sort resukts, UNION ALL doesn't
       > UNION is slower, UNION ALL is faster
   
   > INTERSECT
     > Returns common values from the output of two select statements
     > Example
       > SELECT JOB FROM EMP WHERE DEPT = 20
         INTERSECT 
         SELECT JOB FROM EMP WHERE DEPT = 30
         > CLERK
           MANAGER
   
   > EXCEPT
     > Returns values present in 1st querry output not present in 2nd querry output
     > Example
       > SELECT JOB FROM EMP WHERE DEPT = 20
         EXCEPT
         SELECT JOB FROM EMP WHERE DEPT = 30
         > ANALYST
       > SELECT JOB FROM EMP WHERE DEPT = 30
         EXCEPT
         SELECT JOB FROM EMP WHERE DEPT = 20

 > Question
   > T1 T2
     F1 C1
     1  1
     2  2
     3  3
     10 40
     20 50
     30 60
     > Write outpur from the following operations
      > INNER JOIN
       > LEFT JOIN
      > RIGHT JOIN
       > FULL JOIN
       > UNION
       > UNION ALL
       > INTERSECT
       > EXCEPT
 
 // Google SQL ONLINE Compilers. visit hacker rank for complex querries

070623

 > SUBQUERIES
   ----------
   > Also called NESTED QUERIES
   > A Querry in another querry is called subquery or nested query
   > There is inner/child/sub querry and outer/parent/main query
   > First inner qurry is executed and then outer
   > Outer of inner query is incput to outer qurry
   > Use Subqueries when where condition based on unknown value
   > Types of subquerries
     > Single row
     > Multi row
     > Co-related 
     > Derived
     > Scalar

   > Single row subquery
     > If subquerry returns one row 
     > Syntax
       > SELECT colname FROM tabname WHERE colname OP (SELECT STATEMENT)
       > Operator must be any relational operator like = > >= < <= <>
     > Example
       > Display empleyees earning more than Blake
         > SELECT * FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'BLAKE')
       > Display empleyees who are senior to king
         > SELECT * FROM EMP WHERE HIREDATE < ( SELECT HIREDATE FROM EMP WHERE ENAME = 'KING')
       > Display name of the empleyee earning max sal
         > SELECT * FROM EMP WHERE SAL = MAX(SAL) gives error
         > SELECT * FROM EMP WHERE SAL = ( SELECT MAX(SAL) FROM EMP)
       > Find the name of the empleyee who's having maximum experience
         > SELECT * FROM EMP WHERE HIREDATE = ( SELECT MIN(HIREDATE) FROM EMP)
       > Display 2nd max salary
         > SELECT MAX(SAL) FROM EMP WHERE SAL < ( SELECT MAX(SAL) FROM EMP)
       > Display name of employee earning 2nd max salary
         > SELECT ENAME FROM EMP WHERE SAL = ( SELECT MAX(SAL) FROM EMP WHERE SAL < (SELECT MAX(SAL) FROM EMP))
       > Delete the employee having max experience
         > DELETE FROM EMP WHERE HIREDATE = ( SELECT MIN(HIREDATE) FROM EMP )
       > Swap employee salaries whose empno = 7499, 7521
         > UPDATE EMP SET SAL = CASE EMPNO WHEN 7499 THEN ( SELECT SAL FROM EMP WHERE EMPNO = 7521 ) WHEN 7521 THEN ( SELECT SAL FROM EMP WHERE EMPNO = 7499 ) END
           > ALTER TABLE EMP DROP CONSTRAINT CK__EMP__SAL__59063A47
           > this results in effecting all rows keeping others blank
         > Recreate the table from SQL Server demo tables
         > UPDATE EMP SET SAL = CASE EMPNO WHEN 7499 THEN ( SELECT SAL FROM EMP WHERE EMPNO = 7521 ) WHEN 7521 THEN ( SELECT SAL FROM EMP WHERE EMPNO = 7499 ) END WHERE EMPNO IN ( 7499,7521 )
       > Display name of the employees working at NEWYORK location
         > SELECT * FROM EMP WHERE DEPT = ( SELECT DEPTNO FROM DEPT WHERE LOC = ' NEW YORK' )
         > SELECT E.NAME FROM EMP AS E INNER JOIN DEPT AS D ON E.DEPT = D.DEPTNO WHERE D.LOC = 'NEW YORK'
       > Display ENAME DNAME working at new york location
         > JOIN
           > SELECT E.ENAME, D.DNAME FROM EMP AS E INNER JOIN DEPT AS D ON E.DEPT = D.DEPTNO WHERE D.LOC = 'NEW YORK'
         > SUBQUERRY  
           > not possible
   > JOIN vs SUBQUERRY
     > To display data from one table and condition based on another table then use join or subquerry
     > To display data from two tables then use join operation

080623
 
 > MULTI-SUBQUERRY
   --------------
   > If a subquerry returns more than one row then it is called multi-row subquerry
   > Syntax
     > SELECT columns FROM tabname WHERE colname OP ( SELECT STATEMENT)
     > OP must be IN, NOT IN, ANY, ALL
   > Example
     > Display employees working at NEW YORK, CHICAGO locations
       > SELECT * FROM EMP WHERE DEPTNO = ( SELECT DEPTNO FROM DEPT WHERE LOC IN ('NEW YORK', 'CHOCAGO'))

   > ANY 
     > Use ANY operator for > < comparision with multiple values
       > WHERE X > ANY ( 1000, 2000, 3000)
         IF X = 800 FALSE
                1500  TRUE
                4500  TRUE
       > WHERE X < ANY ( 1000, 2000, 3000)
         IF X = 800 TRUE
                1500  TRUE
                4500  FALSE
   > ALL
     > Use ALL operator for > < comparision with multiple values
       > WHERE X > ALL ( 1000, 2000, 3000)
         IF X = 800  FALSE
                1500  FALSE
                4500  TRUE
       > WHERE X < ALL ( 1000, 2000, 3000)
         IF X = 800  TRUE
                1500  FALSE
                4500  FALSE
   
   > Example
     > Display empleyees earning more than all managers
       > SELECT SAL FROM EMP WHERE SAL > ANY ( SELECT SAL FROM EMP WHERE JOB = 'MANAGER' )
     > Display employees earning more than at least one manager
       > SELECT * FROM EMP WHERE SAL > ANY ( SELECT SAL FROM EMP WHERE JOB = 'MANAGER' )
 
 > CO-RELATED subqueries
   ---------------------
   > If inner query referecnces values of outer query then it is called CO-RELATED subquery
   > In CO-RELATED subquery execution starts from outer query and inner query execution 
     depends on number rows returned by outer query
   > Use CO-RELATED subquery to execute subquery for each row return by outer query
   > Example
     > EMP 
       EMPNO ENAME SAL  DEPTNO
       1     A     3000 10
       2     B     5000 20
       3     c     4000 30
       4     D     6000 10
       5     E     3000 20
       > Display empleyees earning more than avg(SAL) of their dept
         > SELECT * FROM EMP AS X WHERE SAL > ( SELECT AVG(SAL) FROM EMP WHERE DEPTNO = X.DEPTNO )
         1 A 3000 10 3000>(4500) FALSE
         2 B 5000 20 5000>(4000) TRUE
         3 C 4000 30 4000>(4000) FALSE
         4 D 6000 10 6000>(4500) TRUE
         5 E 3000 20 3000>(4500) FALSE
       > Display employees earning max salaries in their department
         > SELECT * FROM EMP AS X WHERE SAL = ( SELECT MAX(SAL) FROM EMP WHERE DEPTNO = X.DEPTNO )
         1 A 3000 10 3000 = (6000) FALSE
         2 B 5000 20 5000 = (5000) TRUE
         3 C 4000 30 4000 = (4000) TRUE
         4 D 6000 10 6000 = (6000) TRUE
         5 E 3000 20 3000 = (6000) FALSE

       > Display top 3 max salaries
         EMPA  EMPB
         SAL   SAL
         5000  5000 3>(0) TRUE
         1000  1000 3>(4) FALSE
         3000  3000 3>(2) TRUE
         2000  2000 3>(3) FALSE
         4000  4000 3>(1) TRUE
         > SELECT DISTINCT A.SAL FROME EMP AS A WHERE 3 > ( SELECT COUNT (B.SAL) FROM EMP AS B WHERE A.SAL < B.SAL) ORDER BY SAL DESC // DISTINCT to eleminate duolicates

090623

 > DERIVED TABLES
   --------------
   > Subqueries in FROM clause are called derived tables
   > Syntax
     > SELECT columns FROM ( SELECT STATEMENT ) AS <alias> [WHERE COND]
     > Here subquery output acts like a table for outer query
   > Derived tables are used in following scenarios
     > To control order of execution of a clauses
       > Default order of SQL Server FROM WHERE GROUP BY HAVING SELECT ORDER BY
       > Example
         > Display rank of employees based on sal
           > SELECT ENAME, SAL, DENSE_RANK() OVER (ORDER BY SAL DESC) AS RANK FROM EMP gives ranks of all the empleyees,
             but to display TOP 5 empleyees
           > SELECT ENAME, SAL, DENSE_RANK() OVER (ORDER BY SAL DESC) AS RANK FROM EMP WHERE RANK <= 5 gives error as
             Alias cannot be used in where clause because where clause is executed before SELECT
           > To overcome this problem first execute SELECT then execute WHERE, use DERIVED TABLE
           > SELECT DISTINCT SAL FROM ( SELECT ENAME, SAL, DENSE_RANK() OVER (ORDER BY SAL DESC) AS RANK FROM EMP) AS E WHERE RANK <= 5 ORDER BY SAL DESC
         > SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER ( ORDER BY EMPNO ASC ) AS RNO FROM EMP
           > The above query returns all the records with record number
           > To display first 5 rows
             SELECT * FROM (SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER ( ORDER BY EMPNO ASC ) AS RNO FROM EMP ) AS E WHERE RNO <= 5
             > Also different condions you can write
               > WHERE RNO IN ( 5,7,11 )
                 WHERE RNO BETWEEN 5 AND 10
                 WHERE RNO %2 = 0
           > Display last 3 rows
             > SELECT * FROM (SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER ( ORDER BY EMPNO ASC ) AS RNO FROM EMP ) AS E WHERE RNO >= ( SELECT COUNT (*) -2 FROM EMP )
           > Delete first 3 rows from EMP table
             > DELETE SELECT * FROM (SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER ( ORDER BY EMONO ASC ) AS RNO FROM EMP ) AS E WHERE RNO <= 3 gives error
             > In derives talbes outer query cannot be DML and it c=must be select, to overcome this use CTEs
               > CTE
                 ---
                 > Common Table Expression, is a named query 
                 > Using CTE we can give name to the query output and we can refer that name in another query like SELECT/INSERT/UPDATE/DELETE
                 > CETs outer query can be SELECT/INSERT/UPDATE/DELETE
                 > Syntax:
                   > WITH <STE-NAME> AS ( SELECT STATEMENT ), ..SELECT/ INSER/ UPDATE/ DELETE
                 > Example
                   > Delete first 3 rows
                     > WITH E AS (SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER ( ORDER BY EMONO ASC ) AS RNO FROM EMP ) DELETE FROM E WHERE RNO <= 3
                   > Delete duolicate rows
                     > Step 1 
                       > Generate row numbers with in the group ( ENO, ENAME, SAL)
                       > SELECT EMNO, ENAME, SAL, ROW_NUMBER() OVER ( PARTITION BY ENO,ENAME,SAL ORDER BY ENO ASC) FROM EMP44
                         1 A 5000 1
                         1 A 5000 2
                         2 B 6000 1
                         2 B 6000 2
                         3 C 7000 1
                     > Step 2 
                       > Delete the records where RNO > 1
                         > WITH E AS ( SELECT EMNO, ENAME, SAL, ROW_NUMBER() OVER ( PARTITION BY ENO,ENAME,SAL ORDER BY ENO ASC) FROM EMP44 ) DELETE FROM E WHERE RNO > 1
                       NOTE: Distinct only deletes from output not from table
     > To use result of one operation in another operation
     > To join query outputs
     
120623

 > SCALAR SUBQUERIES
   -----------------
   > Subqueries in SELECT clause are called Scalar Subqueries
   > Syntax
     > SELECT (subquer1), (subquer2),......FROM tabname WHERE condition
   > The Subquery output acts like a column for outer query
   > Use Scalar Subquery to show the query output in seperate column
   > Examples
     > SELECT ( SELECT COUNT (*) FROM EMP ) AS EMP, ( SELECT COUNT (*) FROM DEPT ) AS DEPT
     > Display department wise total salary
       > SELECT DEPT, SUM(SAL) AS DEPT_TOTSAL, ( SELECT SUM( SAL) FROM EMP ) AS TOTSAL FROM EMP GROUP BY DEPTNO
     > Display DEPTNO DEPT_TOTSAL TOTSAL PCT
       > PCT = ( DEPT_TOTSAL/TOTSAL ) * 100
       > SELECT DEPT, SUM(SAL) AS DEPT_TOTSAL, ( SELECT SUM( SAL) FROM EMP ) AS TOTSAL,( SUM(SAL)/(SELECT SUM(SAL) FROM EMP )) * 100 AS PCT FROM EMP GROUP BY DEPTNO
   > Assignment 
     > SALES
       DATEID PRODID CUSTID QTY AMT

       PRODUCTS
       PRODID PNAME PRICE CATEGORY BRAND
       > Display category wise total amount 
         > CATEGORY    CAT_AMT
           ELECTRONICS ?
           MENS        ?
           > Display CATEGORY CAT_AMT TOTAL_AMT
       > T1
         AMT
         1000
         -200
         2000
         -500
         3000
         -1000
         > Display POS NEG 
                  1000 -200
                  2000 -500
                  3000 -1000
       > T1  T2
         F1  C1
         1   A
         2   B
         3   C
         > Write a query display following output
           > 1 A
             2 B
             3 C
 > PIVOT Operator
   --------------
   > Operator used to convert rows into columns
   > Used for cross tabulation or to display data in matrix form
   > Syntax 
     > SELECT * FROM ( SELECT STATEMENT ) AS <alias> PIVOT ( AGGRE-EXPR FOR COLNAME IN ( V1, V2, V3,...)) AS <PIVOT-TBL-NAME> ORDER BY COLNAME ASC/DESC
   > Example
     > Display
                       10  20  30
       ANALYST          ?   ?   ?     
       CLERK            ?   ?   ?
       MANAGER          ?   ?   ?
       SALESMAN         ?   ?   ?
       > SELECT * FROM ( SELECT DEPTNO, JOB, SAL FROM EMP ) AS E PIVOT ( SUM (SAL) FOR DEPTNO IN ([10], [20], [30],)) AS PIVOT_TBL ORDER BY JOB ASC
     > Display
            1  2  3  4 
       1980 ?  ?  ?  ?
       1981 ?  ?  ?  ?
       1982 ?  ?  ?  ?
       1983 ?  ?  ?  ?
     > STUDENT
       SNO SNAME SUBJECT MARKS
       1   A     MAT     80
       1   A     PHY     60
       1   A     CHE     70
       2   B     MAT     60
       2   B     PHY     40
       2   B     CHE     50
       > Display OUPUT 
         SNO SNAME MAT PHY CHE
        1    A     80   60  70
        2    B     60   40  50
        > SELECT * FROM STUDENT PIVOT ( SUM ( MARKS) FOR SUBJECT IN ([MAT], [PHY], [CHE])) AS PIVOT_TBL ORDER BY SNO ASC

 > Create a new table from existing table ( replica )
   --------------------------------------------------
   > Syntax 
     > SELECT COLUMNS INTO <new-tablename> FROM <old-tabname> WHERE CONDITION
   > Example
     > SELECT * INTO EMP11 FROM EMP
       > A new table is created with name EMP11 with rows and columns return by select statement
     > Copying specific rows and columns
       > SELECT EMPNO, ENAME, JOB, SAL INTO EMP12 FROM EMP WHERE JOB IN ( 'CLERK', 'MANAGER' )
     > Copy only the columns ( structure ) but not rows ( data ) 
       > SELECT * INTO EMP13 FROM EMP WHERE 1 = 2 // any false condition 

130623

 > MERGE Command
   -------------
   > Command used to merge data into a table
   > Merge is the combination of insert, update and delete
   > Used to manage replicas ( duplicate copy )
   > Using merge command we can apply changes made for one table to another table
   > syntax
     > MERGE INTO <target-table> AS <alias> USING <source-table> AS <alias> ON <condition> WHEN MATCHED THEN UPDATE WHEN NOT MATCHED THEN INSERT [WHEN NOT MATHED BY SOURCE THEN DELETE]
   > Example:
     > Step 1:
       > Create source table 
         CREATE TABLE CUSTS ( CID INT, NAME VARCHAR(10), CITY CHAR(3) ) INSERT INTO CUSTS VALUES ( 10, 'A', 'HYD'), (11, 'B', 'MUM')
         CUSTS
         CID NAME CITY
         10  A    HYD
         11  B    MUM
       > Step 2:
         > Create Replica
           SELECT * INTO CUSTT FROM CUSTS
           CUSTT
           CID NAME CITY
           10  A    HYD
           11  B    MUM
       > Step 3:
         > Modify Source Table
           INSERT INTO CUSTS VALUES ( 12, 'C', 'DEL') UPDATE CUST SET CITY = 'BLR' WHERE CID = 10
           CUSTS
           CID NAME CITY
           10  A    BLR // updated 
           11  B    MUM
           12  C    DEL // updated
       > Step 4:
         > Execute MERGE command to apply changes to replica
           MERGE INTO CUSTT AS T  USING CUSTS AS S ON ( S.CID = T.CID ) WHEN MATCHED THEN UPDATE SET T.CITY = S.CITY WHEN NOT MATHCHED THEN INSERT VALUES ( S.CID. S.NAME, S.CITY )
           SELECT * FROM CUSTT
           CID NAME ADDR
           10  A    BLR
           11  B    MUM
           12  C    DEL
   > Assignment
     > EMPS 
       EMPID ENAME SAL
       1     A     5000
       2     B     3000
       3     C     4000
       EMPT
       EMPID ENAME SAL
       1     A
       2     B
       3     C
       > Copy salaries from EMPS to EMPT

 > DATABASE TRANSACTIONS
   =====================
   > A transaction is a unit of work that contains one of more DMLs
     that must be saved as a whole or cancelled as a whole
   > Example
     > Money transfer
       Acc1             Rs1000    Acc2
       update1                    update2
       (bal=bal-1000)             (bal=acc1+1000)
       successful                 Failed             gives invalid
       failed                     Successful         gives invalid
       Successful                 Successful         gives valid
       failed                     failed             gives valid
   > Every transaction must gurantee a property called automocity i.e., all or none
   > If transaction contains multiple operations, if all operations are successful then if must be saved,
     if any of the operations fails then entire transaction must be cancelled.
   > The following commands provided by SQL Server to handle the transactions
     > COMMIT           = to save transaction
     > ROLLBACK         = to cancel transaction
     > SAVE TRANSACTION = to cancel part of transaction
   > In SQL Server a transaction begins implicitly with DML command and ends implicitly with commit
   > User can also start transaction explicitly by executing "BEGIN TRANSACTION" command and 
     end exaclty with COMMIT/ROLLBACK
   > Example
     > CREATE TABLE A( A INT )     => Implictly committed
       BEGIN TRANSACTION         => Transaction begins T1
       INSERT INTO A VALUES(10)  
       INSERT INTO A VALUES(20) 
       INSERT INTO A VALUES(30)
       COMMIT                    => Ends Transaction
       > If transaction ends with commit then its called successful transaction and operations are saved

     > CREATE TABLE A( A INT )     => Implictly committed
       BEGIN TRANSACTION         => Transaction begins T1
       INSERT INTO A VALUES(10)  
       INSERT INTO A VALUES(20) 
       INSERT INTO A VALUES(30)
       ROLLBACK                  => Transaction cancelled // all the aboce inserts cancelled
       > If a transaction ends with rollback then it is called aborted transaction and operations are cancelled

     > CREATE TABLE A( A INT )     => Implictly committed
       BEGIN TRANSACTION         => Transaction begins T1
       INSERT INTO A VALUES(10)  
       INSERT INTO A VALUES(20) 
       COMMIT                    => Ends Transaction     // above transactions are saved
       INSERT INTO A VALUES(30)  => Implicitly committed
       INSERT INTO A VALUES(40)  => Implicitly committed
       ROLLBACK                  => Trying to end transaction without starting // gives error

   > SAVE TRANSACTION
     ----------------
     > We can declare save transaction and we can rollback upto  the save transaction
     > Using SAVE TRANSACTION we can cancel part of the transaction
     > Example
       > CREATE TABLE A( A INT )     
         BEGIN TRANSACTION         
         INSERT INTO A VALUES(10)  
         INSERT INTO A VALUES(20)
         SAVE TRANSACTION ST1 
         INSERT INTO A VALUES(30)
         INSERT INTO A VALUES(40)
         SAVE TRANSACTION ST2
         INSERT INTO A VALUES(50)
         INSERT INTO A VALUES(60)
         ROLLBACK TRANSACTION ST1
         
140623

 > DATABASE SECURITY
   -----------------
   > There are 4 facilities to provide security in SQL SERVER
     LOGINS (SERVER)              => Provides security at server level
       USERS (DATABASE)           => Provides security at DB level
         PRIVILAGES (TABLES)      => Provides security at table level
           VIEWS (ROWS & COLUMNS) => Provides security at row and column level

 > Creating LOGIN
   --------------
   > Object Explorer
     > SECURITY
       > LOGINS
         > SQL SERVER Auth
         > Password
         > Login
         > ...
         > ...
         > ...
         > ...
         > OK  // New login is created
     > 
 > CREATING NEW USER
   -----------------
   > DB 
    > SECURITY 
       > USERS 
         > (right click) New User
           > 

150623

 > Granting permission on view to user
   -----------------------------------
   > GRANT SELECT, INSERT, UPDATE, DELETE ON V1 TO VIJAY
     > VIJAY
       > SELECT * FROM V1
         UPDATE V1 SET JOB = 'CLERK' WHERE EMPNO = 7566
         UPDATE V1 SET SAL = '5000' WHERE EMPNO = 7566 gives error
   > ROW LEVEL SECURITY
     ------------------
     > CREATE VIEW V2 AS SELECT EMPNO, ENAME, JOB, DEPT FROM EMP WHERE DEPT = 20
     > GRANT SELECT, INSERT, UPDATE, DELETE ON V2 TO VIJAY
       > VIJAY 
         > INSERT INTO V2 VALUES(8888, 'ABC', 'MANAGER',30) shows 1 row effected
           > The above INSERT command executed successfully eventhough its violating where condition
   > WITH CHECK OPTION
     -----------------
     > Any view created "WITH CHECK OPTION" then any dml cmd throught view violates condition then that dml is not accepted
       > CREATE VIEW V3 AS SELECT EMPNO, ENAME, JOB, DEPT FROM EMP WHERE DEPT = 20 WIHT CHECK OPTION
       > GRANT SELECT, INSERT, UPDATE, DELETE ON V3 TO VIJAY
         > VIJAY
           >  INSERT INTO V3 VALUES( 7777, 'KLM', 'CLERK', 30 ) gives error
   > COMPLEX VIEWS
     -------------
     > A VIEW said to be complex view if 
       > Based on multiple tables
       > Querry contains GROUP BY, DISTINCT, AGGREGATE functions, SUBQUERRIES, SET OPERATORS
       > With the help of views complex querries can be converted into simple querries
     > Example
       > CREATE VIEW CV1
         AS 
         SELECT E.EMPNO, E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC 
         FROM EMP AS E INNER JOIN DEPT AS D 
         ON E.DEPT = D.DEPTNO
         > After creating VIEW whenever we want data from EMP and DEPT tables then instead of writing join querry 
           write the simple querry as follows
           > SELECT * FROM CV1
       > SELECT DEPT, SUM ( E.SAL ) AS TOTSAL 
         FROM EMP AS E INNER JOIN DEPT AS D
         ON E.DEPT = D.DEPTNO
         GROUP BY D.DNAME 
         or 
         CREATE VIEW CV2 AS
         SELECT D.DNAME, SUM ( E.SAL ) AS TOTSAL 
         FROM EMP AS E INNER JOIN DEPT AS D
         ON E.DEPT = D.DEPTNO
         GROUP BY D.DNAME 
         > Now whenever we want dept wise summery execute 
           SELECT * FROM CV2
   > Difference between SIMPLE and COMPLEX views
     > SIMPLE based on single table, COMPLEX based on multiple tables
     > SIMPLE performs simple operations, COMPLEX performs complex operations like JOIN, GROUP BY, AGGREGATE
     > SIMPLE views always updatable i.e., allows DML operaions, COMPLEX views not updatable i.e., does't allow DML operations
   > LIST of TABLES & VIEWS created by users
     ----------------------------------------
     > SELECT * FROM INFORMATION_SCHEMA.TABLES
     > SELECT * FROM INFORMATION_SCHEMA.VIEWS
   > DROPING VIEW
     ------------
     > DROP VIEW V1
       > Can we access views if the talbes are dropped ?
         > VIEWS are not DROPPED but VIEWS cannot be querried
   > SYNONYMS
     --------
     > Another name for a TABLE/VIEW
     > If TABLE name is lengthy then we can give a simple and short name to the talbe called synonym
       and instead of using tablename we can use synonym name in SELECT/INSET/UPDATE/DELETE querries
     > Syntax
       > CREATE SYNONYM <name> FOR <tabname>
     > Example
       > CREATE SYNONYM E FOR EMP
     > After creating synonym use system name in SELECT/INSET/UPDATE/DELETE querries
       > SELECT * FROM E
       > UPDATE E SET SAL = 2000 WHERE EMPNO = 7369
     > Questions
       > CREATE SYNONYM E FOR EMP,
         SELECT * FROM EMP AS E,
         SP_RENAME 'EMP','E'
         Difference between these querries
         > SYNONYM is Permanent, ALIAS is not permanent
         > SYNONYM is stored in DB, ALIAS is not stored in DB
         > SYNONYM can be used with in SCHEMA, ALIAS can be used with in with in a querry
     > DROP SYNONYM
       ------------
       > DROP SYNONYM E
   > Generating values for PRIMARY key columns
     -----------------------------------------
     > 1. IDENTITY
       2. SEQUENCE
     > IDENTITY
       > Used to generate sequence number
       > Used to auto increment column values
       > Syntax
         > IDENTITY ( SEED, INCR )
           > SEED means start, its optional, default is 1
           > INCR means increment, its optional, default is 1
       > Example
         > CREATE TABLE CUST
           ( 
            CID INT IDENTITY ( 100, 1 ), 
            NAME VARCAHR(10)
           )
         > INSERT INTO CUST(NAME) VALUES('A')
         > INSERT INTO CUST(NAME) VALUES('B')
         > INSERT INTO CUST(NAME) VALUES('C')
         > INSERT INTO CUST(NAME) VALUES('D')
         > INSERT INTO CUST(NAME) VALUES('E')
         > SELECT * FROM CUST
           CID NAME
           100 A
           101 B
           102 C
           103 D
           104 E
           
160623

         > DELETE FROM CUST // deletes all rows
         > INSERT INTO CUST (NAME) VALUES( 'K')
           > CID NAME   
             105 K  // identity not recet 
         > TRUNCATE TABLE CUST // delete all rows
         > INSERT INTO CUST (NAME) VALUES( 'X')
           > CID NAME
             100 X    // identity recet
         > NOTE: 
           > DELETE will not recet identity but TRUNCATE will recet identity
         > INSERT INTO CUST (NAME) VALUES ('C')
         > INSERT INTO CUST (NAME) VALUES ('k')

       > How to reset the identity manually ( DATA BASE CONSISTENCY CHECK )
         ----------------------------------
         > Syntax
          > DBCC CEHCKIDENT ( TABLE NAME, RESEED, VALUE)
         > Example
          > Here to recet the identity
             > DBCC CEHCKIDENT ('CUST', RESEED, 99) // identity is recet to 99
           > INSERT INTO CUST (NAME) VALUES ('P')   // identity starts from 100

       > IDENTITY INSERT
         ---------------
        > By default explicit value not allowed into identity column
         > Execute the following command to insert value into identity column explicitly
         > Syntax
           > SET IDENTITY_INSERT CUST ON
         > Example
           > SET IDENTITY_INSERT CUST ON
           > INSERT INTO CUST (CID,NAME) VALUES(110,'Q') // ome row created
     
     > USING SEQUENCE
       --------------
       > CREATE SEQUENCE <name>
         [START WITH <value>]
         [INCREMENT By <value>]
         [MAXVALUE <value>]
         [MINVALUE <value>]
         [CYCLE / NOCYCLE]
         [CACHE <size>]
       > WHERE CAN YOU FIND SEQUENCE IN YOUR DB?
          > <your DB> 
            > PROGRAMMABILTY
             > SEQUENCES
               > <your sequence>
       > Example
         > CREATE SEQUENCE S1
           START WITH 1
           INCREMENT BY 1
           MAXVALUE 5
           CREATE TABLE STUDENT
           (
            SID INT PRIMARY KEY,
            SNAME VARCHAR(10)
           )
           INSERT INTO STUDENT VALUES( NEXT VALUE FOR S1, 'A')
           INSERT INTO STUDENT VALUES( NEXT VALUE FOR S1, 'B')
           INSERT INTO STUDENT VALUES( NEXT VALUE FOR S1, 'C')
           INSERT INTO STUDENT VALUES( NEXT VALUE FOR S1, 'D')
           INSERT INTO STUDENT VALUES( NEXT VALUE FOR S1, 'E')
           INSERT INTO STUDENT VALUES( NEXT VALUE FOR S1, 'F') error since MAXVALUE is '5'
           SELECT * FROM STUDENT
           SID NAME
           1   A
           2   B
           3   C
           4   D
           5   E

         > CREATE SEQUENCE S2
           START WITH 100
           INCREMENT BY 1
           MAXVALUE 999
           > Use above sequence to update EMPNO
             > UPDATE EMP SET EMPNO = NEXT VALUE FOR S2
             > SELECT * FROM EMP // updated with sequence
         
         > CREATE Table
            INVOICE
            INVNO       INVDT  AMT  
            NIT/0623/1  ?      ?
            NIT/0623/2  ?      ?
            .           .      .
            .           .      .
            .           .      .
            .           .      .
            > CREATE TABLE INVOICE
              (
                INVNO VARCHAR(20)
                INVDT DATETIME,
                AMT   MONEY
              )
              CREATE SEQUENCE S3
              START WITH 1
              INCREMENT BY 1
              MAXVALUE 999
              INSERT INTO INVOICE VLAUES ( 'NIT/'+ FORMAT(GETDATE(),'MMyy')+'/'+ CAST(NEXT VALUE FOR S3 AS VARCAHR), GETDATE(),1000)
              INSERT INTO INVOICE VLAUES ( 'NIT/'+ FORMAT(GETDATE(),'MMyy')+'/'+ CAST(NEXT VALUE FOR S3 AS VARCAHR), GETDATE(),2000)
              INSERT INTO INVOICE VLAUES ( 'NIT/'+ FORMAT(GETDATE(),'MMyy')+'/'+ CAST(NEXT VALUE FOR S3 AS VARCAHR), GETDATE(),3000)

       > How to restart sequence
         -----------------------
         > ALTER, CYCLE are used
         > Using ALTER 
           ----------
           > ALTER SEQUENCE S3 RESTART WITH 1
         > Using CYCLE
           -----------
           > By default sequence created with NOCYCLE, it starts from start with and generates upto max and after recahing max then it stops
           > If sequence created with CYCLE then it starts from start with and generates upto max and after reaching max then it will reset to min
           > Example
             > CREATE SEQUENCES5
               STAT WITH 1
               INCREMENT BY 1
               MAXVALUE 5
               MINVALUE 1
               CYCLE
             > To check the sequence
               > SELECT NEXT VALUE FOR S5

       > To view all the sequence information list
         -----------------------------------------
         > SELECT * FROM INFORMATION_SCHEMA.SEQUENCES

       > Drop sequence
         -------------
         > DROP SEQUENCE
       
       > Difference between IDENTITY & SEQUENCE
         ---------------------------------------
         > IDENTITY is bound to a particular column in a table, SEQUENCE can be used for any column and any table
         > A row has to be inserted to generate IDENTITY value but SEQUENCE next value can be generated by calling next value for sequence
         > IDENTITY, SEQUENCE both can be reset
         > MAXVALUE cannot be decalered for IDENTITY but can be decalred for SEQUENCE
         
170623

 > INDEXES
   -------
   > A DB object created to improve the performance of data accessing
   > Index in DB is similar to index in a book, in a book using index a particular topic can be located quickly and in same way here in DB
     using INDEX a particular row can be located quickly
   > Indexes are created on columns and  that column is called index key
   > Indexes are created on columns that are used in 
      WHERE Clause
      JOIN operaions
      
   > Where to find INDEXES?
     ---------------------
       > DB
         > TABLES
           > <table>
             > INDEXES

   > To view INDEXES of a table
     ---------------------------
     > SP_HELPINDEX <table name> 

   > Types of INDEXES
     > Non Clustered
       > Simple 
       > Composite
       > Unique
     > CLustered
   > Simple Non-Clustered Index
     --------------------------
     > If Index created on single column then it is called Simple Index
     > Syntax
       > CREATE INDEX <name> ON <tabname> ( COLNAME )
     > Example
       > CREATE INDEX I1 ON EMP (SAL)
       > After executing above command SQL SERVER creates a structure called BTREE ( Balanced Binary Tree )
       > EMP                       3000
         SAL                       
         5000
         1000                2000               4000
         3000          
         2000          1000*       2500*  4000*
         1500          1500*       3000*,*
         4000          2000*
         3000
         2500

     > When we submit a querry, SQL Server uses the following methods to find the record
       > TABLE SCAN
       > INDEX SCAN
       > In TABLE SCAN SQL Server scans complete table i.e., and every row but in INDEX SCAN only half
         of the talbe, so INDEX SCAN is much faster then TABLE SCAN
       > SELECT * FROM EMP WHERE SAL = 3000 for this querry SQL SERVER uses INDEX SCAN
       > SELECT * FROM EMP WHERE SAL >= 3000 for this querry SQL SERVER uses INDEX SCAN
       > SELECT * FROM EMP WHERE SAL <= 3000 for this querry SQL SERVER uses INDEX SCAN
       > SELECT * FROM EMP WHERE ENAME = 'BLAKE' ( TABLE SCAN )

     > COMPOSITE INDEX
       ---------------
       > If INDEX created on multiple columns then INDEX is called composite index
       > CREATE INDEX I2 ON EMP(DEPTNO, JOB)
         EMP 
         DEPTNO  JOB
         10      CLERK
         20      MGR
         30      SALESMAN
         20      CLERK
         30      CLERK
         10      MGR
         30      SALESMAN
         20      CLERK
         > The following structure is created after executing command 
                                              20  

                         10                                         30
           
           10  CLERK *         20 CLERK *,*         30 CLERK *
           10  MGR *           20 MGR *             30 SALESMAN *, *
         > SQL SERVER uses aboice INDEX when WHERE condition is based on first column of index i.e., DEPTNO
       > SELECT * FROM EMP WHERE DEPTNO = 20 ( INDEX SCAN )
       > SELECT * FROM EMP WHERE DEPTNO = 20 AND JOB = 'CLERK' ( INDEX SCAN )
       > SELECT * FROM EMP WHERE JOB = 'CLERK' ( TABLE SCAN )
    

     > UNIQUE INDEX 
       ------------
       > UNIQUE INDEX doesn't allow duolicate values into which index is created
       > Example
         > CREATE UNICODE INDEX I3 ON EMP( ENAME )
                                                
                                                K

                              G                                  Q

          ADAMS *                   JAMES *           MARTIN *        SACHIN *
          ALLEN *                   JONES *           MILLER *        SMITH *
          BLAKE *

          > SELECT * FROM EMO WHERE ENAME = 'BLAKE'
          > INSER INTO EMP ( EMPNO, ENAME, SAL ) VALUES ( 8888, 'BLAKE', 4000 ) gives error
       > Other Methods to enforce UNIQUE
         > Declare PRIMARY KEY / UNIQUE CONSTRAINT
         > CREATE UNIQUE INDEX
         > Example
           > CREATE TABLE STUDENT
             (
              SID INT PRIMARY KEY,
              SNAME VARCAHR ( 10 )
             )                         // UNIQUE INDEX is created
             
       > NOTE:
         > PRIMARY KEY / UNIQUE columns are automatically indexed by SQL SERVER
         > A Unique index is created on PRIMARY KEY / UNIQUE columns and UNIQUE INDEX allow 
           duplicates so PRIMARY KEY / UNIQUE also doen't allow duplicates

190623

 > Cluster Index
   -------------
   > Cluster index stores actual records, where as Non-Clustered index stores pointer to actual records
   > In Cluster Index Index and table is one, Non-Clustered index index and table are seperate
   > By default Index is Non-Clustered for SQL Server, to create Cluster Index use keyword 'CLUSTERED'
   > Example
     > CREATE TABLE CUST
       (
        CID INT,
        CNAME VARCHAR(10)
       )
       CREATE CLUSTERED INDEX I10 ON CUST(CID)
       INSERT INTO CUST VALUES ( 10,'A' )
       INSERT INTO CUST VALUES ( 60,'B' )
       INSERT INTO CUST VALUES ( 40,'C' )
       INSERT INTO CUST VALUES ( 80,'D' )

                                                 50
                          30                                            70
              10 A                  40C                     60 B                80 D
       SELECT * FROM CUST WHERE CID = 60 
       SELECT * FROM CUST here SQL SERVER goes to clustered index and access all the leaf nodes from left to right
       10 A
       40 C
       60 B
       80 D
   > Note :
     > Only One Clustered Index is allowed per table
     > By default Clustered Index is created on PRIMARY KEY Column
     > Because of cluster index in tables data automatically sorted based on PRIMARY KEY Column
   > Difference between Non-Clustered Index and Clustered Index
     > Non-Clustered Index stores pointers to actual records where as Clustered Index stores actual records
     > Non-Clustered Index needs extra memory, Clustered Index don't need extra memory
     > Non-Clustered Table and Index are seperate objects and Clustered Index Table and Index are one
     > Non-Clustered Index requires two lookups to find required row/rows and Clustered Index requires only one lookup to find row/rows
     > 999 Non-Clustered Indexes allowed per table and Only One Clustered Index allowed per table
     > By default Non-Clustered Indexes is created on UNIQUE KEY column where as by Default Clustered Index is created on PRIMARY KEY column

 > Dropping Index
   --------------
   > Syntax
     > DROP INDEX EMP.I1
   > If Table is dropped Indexes are also dropped

 --------------------------------------------------------------------------------------------------------------------------

 > Summary
   =======
   > Commands
     > DDL 
       DML 
       DQL 
       TCL 
       DCL
   > clauses
     > WHERE 
       ORDER BY 
       DISTINCT 
       TOP 
       GROUP BY 
       HAVING
       ON
   > operations
     > FILTERING
       SORTING
       ELEIMINATING DUPLICATES
       TOP N ROWS
       GROUPING
       JOINING
       SET OPERATIONS
       FUNCTIONS
       SUBQUERIES
   > OBJECTS
     > TABLES
       VIEWS
       SYNONYMS
       SEQUENCES
       INDEXES

   > PROCEDURES // this is in programming part
     FUNCTIONS
     TRIGGERS
 ----------------------------------------------------------------------------------------------------

 > T-SQL PROGRAMMING ( TRASANCT-SQL )
   -----------------
   > Topics
     > Basic Programming
     > Conditional statements
     > Loops
     > Cursors
     > Qeeoe Handling
     > Procedures
     > Fucntions
     > Triggers
     > Dynamic SQL
   
   > Features of T-SQL Programming
     > Improves performance
       > SQL Commands can be grouped into one block and can be submitted to SQL SERVER
         > Number of requests and responses are reduced resulting in imporvemt of preformance
     > T-SQL Supports Conditional Statments
       > We can Execute SQL conmmands based on conditions
     > T-SQL Supports Looping statements
       >  like WHILE, so T-SQL we can execute SQL commands repeatedly multiple times
     > T-SQL Supports Error handling
       > In T-SQL if any statement causes error then we can handle that error  and we can replace
         system generated message with our own simple and user friendly message
     > T-SQL supports resuability
       > T-SQL preogramms can be stored in DB and applications which are connected to DB can resuse these programs
  
   > The following statements are used in T-SQL Programming
     > DECLARE
     > SET
     > PRINT
   > DECLARE
     -------
     > Used to declare variables
     > Synatax
       > DECALRE @VARNAME DATATYPE(SIZE)
     > Examples
       > DECLARE @X INT
       > DECLARE @S VARCHAR(10)
       > DECLARE @D DATE
       > DECLARE @X INT, @S VARCHAR(10), @D DATE
   > SET 
     ---
     > Used to assign value to variable
     > Syntax
       > SET @VARNAME = VALUE
     > Example
       > SET @X = 100
       > SET @S = 'ABC'
       > SET @D = GETDATE()
   > PRINT
     -----
     > Used to print messages or values stored in variables
     > Syntax
       > PRINT message / variable
     > Example
       > PRINT 'hello'
       > PRINT @X

200623

       > DECLARE @a INT, @b INT, @c INT
         SET @a = 100
         SET @b = 200
         SET @c = @a + @b
         PRINT @c
       > Write program to input date and print day of the week
         > DECLARE @d DATE
           SET @d = '2023-01-01'
           PRINT DATENAME( DW,@d)
 
 > DB Programming with T-SQL
   -------------------------
   > To perform operations over db execute SQL commands from T-SQL program
   > The following commands can be executed from T-SQL program
     > DML ( INSERT, UPDATE, DELETE, MERGE )
       DQL ( SELETCT )
       TCL ( COMMIT, ROLLBACK, SAVE TRANSACTION )

   > SELECT statement syntax
     -----------------------
     > SELECT @var1 = col1, 
              @var2 = col2,....
       FROM TABNAME
       WHERE CONDITION
     > Example
       > SELECT @N = ENAME, @S = SAL
         FROM EMP
         WHERE EMPNO = 110
       > Write program to print name & salary of particular empleyee
         > DECALRE @N VARCHAR(10), @S MONEY
           SELECT @N = ENAME, @S = SAL FROM EMP WHERE EMPNO = 110
           PRINT @N + '' + CAST( @S AS VARCHAR )
       > Write a program to input empno and print experience of the employee
         > DECALRE @ENO INT, @HIRE DATE, @EXPR INT
           SET @ENO = 107
           SELECT @HIRE = HIREDATE FROM EMP WHERE EMPNO = @ENO
           SET @EXPR = DATEDIFF(  YY, @HIRE, GETDATE() )
           PRINT CAST( @EXPR AS VARCHAR ) + 'YEARS'
   
   > Conditional statements
     ----------------------
     > T-SQL supports
       > IF-ELESE
         MULTI IF
         NESTED IF
     
     > IF-ELSE
       > IF condition
           BEGIN 
             STATEMENTS
           END
         ELSE
           BEGIN
             STATEMENTS
           END
     
     > MULTI IF 
       > IF condition1
           BEGIN 
             STATEMENTS
           END
         ELSE IF condition2
           BEGIN 
             STATEMENTS
           END
         ELSE IF condition3
           BEGIN 
             STATEMENTS
           END
         ELSE
           BEGIN 
             STATEMENTS
           END

     > NESTED IF
       > Example
         > Write a program to input EMPNO and increment SAL by specific amount and after increment if SAL exceeds 5000 then cancel that increment
           > DECALRE @ENO INT, @AMT MONEY, @SAL MONEY
             SET @ENO = 107
             SET @AMT = 2500
             BEGIN TRANSACTION   // by default SQL implicitly commits all changes, to make it explicituse BEGIN TRANSACTION
             UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO = @ENO
             SELECT @SAL = SAL FROM EMP WHERE EMPNO = @ENO
             IF @SAL > 5000
                ROLLBACK       
             ELSE 
                COMMIT
         > Write a program to input the EMPNO and increment SAL as follows
           > if JOB is CLERK increment SAL by 10%
             if JOB is SALESMAN increment SAL by 20%
             if JOB is MANAGER increment SAL by 30%
             if JOB is OTHERS increment SAL by 5%
           > DECLARE @ENO INT, @JOB VARCHAR(10), @PCT INT
             SET @ENO = 110
             SELECT @JOB = JOB FROM EMP WHERE EMPNO = @ENO
             IF @JOB = 'CLERK'
                SET @PCT = 10
             ELSE IF @JOB = 'SALESMAN'
                SET @PCT = 20
             ELSE IF @JOB = 'MANAGER'
                SET @PCT = 30
             ELSE 
                SET @PCT = 5
             UPDATE EMO SET SAL = SAL + ( SAL * @PCT/100 ) WHERE EMPNO = @ENO
         
         > Write a program to input EMPNO and increment salary as follows 
           > if year of JOIN = 1980 incr SAL by 30%
             if year of JOIN = 1981 incr SAL by 20%
             if year of JOIN = 1982 incr SAL by 10%
             if others incr SAL by 5%
           > SELECT @YEAR = DATEPART(YY, HIREDATE) FROM EMP WHERE EMPNO = @ENO
             
220623

 > DECALRE @D1 DATE, @D2 DATE
   SET @D1 = '2023-01-02'
   SET @D2 = '2023-12-31'
   /* to find 1st sunday */
   WHILE( DATENAME (DW, @D1) <> 'SUNDAY')
   BEGIN
   SET @D1 = DATEADD(DD, 1,@d1)
   END/* to print saundays */
   WHILE (@D1 <= @D2)
   BEGIN 
   PRINT CAST (@D1 AS VARCHAR) + '    ' + DATENAME ( DW, @D1)
   SET @D1 = DATEADD( DD,7,@D) 
 
 > Write a prog to input string and print the following Pattern
   Output 
    > N
      A
      R
      E 
      S 
      H
    > DECALRE @S VARCHAR(20), @X INT = 1
      SET @S = 'NARESH'
      WHILE (@X <= LEN (@S))
      BEGIN
      PRINT SUBSTRING ( @S, @X, 1 )
      SET @X = @X + 1
      END
 > SUBSTRING syntax
   > SUBSTRING ( STRING, START, LEN )
 
 > Write a program to input string and print the following 
   > Output
     > N
       NA
       NAR
       NARE
       NARES
       NARESH
   > DECALRE @S VARCHAR(20), @X INT = 1
     SET @S = 'NARESH'
     WHILE (@X <= LEN (@S))
     BEGIN
     PRINT SUBSTRING ( @S, 1, @X )
     SET @X = @X + 1
     END
 
 > CURSORS
   -------
   > Used to process multiple rows row-ny-row into T-SQL program
   > Using cursor we can process multiple rows in T-SQL program
   > From T-SQL Program if you submit a query, SQL SErver goes to 
     DB and copies table data into temporay memory called cursor 
     and in T-SQL  program we can give name to that memory and access 
     row-by-row into T-SQL program and process the row
   > Follow the below steps to use cursor in T-SQL program
     > 1 DECALRE CURSOR
     > 2 OPEN CURSOR
     > 3 FETCH RECORDS FROM CURSOR
     > 4 CLOSE CURSOR
     > 5 DEALLOCATE CURSOR

   > DECLARE CURSOR
     --------------
     > Syntax
       > DECALRE <name> CURSOR FOR SELECT STATEMENT
     > Example
       > DECLARE C1 CURSOR FOR SELECT * FROM EMP

   > OPEN CURSOR
     -----------
     > Syntax
       > OPEN <cursor-name>
     > Example
       > OPEN C1
     > Steps happening
       > 1 Select statement submitted to SQL Server
       > 2 Data returned by querry is copied to cursor

   > FETCHING RECORDS FROM CURSOR
     -----------------------------
     > "FETCH" statement is used to fetch record from cursor
     > Syntax
       > FETCH NEXT FROM <cursor> INTO <variables>
     > Example
       > FETCH NEXT FROM C1 INTO @a, @b, @c,......
     > FETCH Statement fetches one row at a time but to process muilple rows FETCH statement should be in a loop
   
   > CLOSING CURSOR
     --------------
     > Synatax
       > CLOSE <cursor-name>
     > Example
       > CLOSE C1

   > DEALLOCATE Cursor
     -----------------
     > Syntax
       > DEALLOCATE <cursor-name>
     > Example
       > DEALLOCATE C1

  > @@FETCH_STATUS
    --------------
    > In '@' prefix means User Defined, with '@@' prefix its a system defined variable
    > @@FETCH_ STATUS is a system or predefined variable that returns fetch status
    > Returns 0 if fetch is successful
              -1 if fetch is not successful
    > Syntax example
      > Write a program to print all employee names and salaries
        > DECALRE C1 CURSOR FOR SELECT ENAME, SAL FROM EMP
          DECALRE @NAME VARCHAR(10), @SAL MONEY
          OPEN C1
          FETCH NEXT FROM C1 INTO @NAME, @SAL
          WHILE ( @@FETCH_STATUS = 0 )
          BEGIN
          PRINT @NAME + ' ' + CAST( @SAK AS VARCHAR )
          FETCH NEXT FROM C1 INTO @NAME, @SAL
          END
          CLOSE C1
          DEALLOCATE C1

      > Write a program to calculate total SAL without using SUM function
        > DECALRE C1 CURSOR FOR SELECT SAL FROM EMP
          DECALRE @SAL MONEY, @TOTSAL MONEY = 0
          OPEN C1
          FETCH NEXT FROM C1 INTO @SAL
          WHILE ( @@FETCH_STATUS = 0 )
          BEGIN
          SET @TOTSAL = @TOTSAL + @SAL
          FETCH NEXT FROM C1 INTO @SAL
          END
          PRINT @TOTSAL
          CLOSE C1
          DEALLOCATE C1

230623

 > Write a program to calculate max salary without using max function
   > DECLARE C1 CURSOR FOR SELECT SAL FROM EMP
     DECALRE @SAL MONEY, @MAX MONEY=0
     OPEN C1
     FETCH NEXT FROM C1 INTO @SAL
     WHILE ( @@FETCH_STATUS = 0)
     BEGIN
     IF @SAL > @MAX
     SET @MAX = @SAL 
     FETCH NEXT FROM C1 INTO @SAL
     END
     PRINT @MAX
     CLOSE C1
     DEALLOCATE C1
   > Method 2
     DECLARE C1 CURSOR FOR SELECT SAL FROM EMP ORDER BY SAL DESC
     DECALRE @SAL MONEY 
     OPEN C1
     FETCH NEXT FROM C1 INTO @SAL
     PRINT @SAL
     CLOSE C1
     DEALLOCATE C1
 > Write a program to print min salary without using min function
   > DECALRE C1 CURSOR FOR SELECT SAL FROM EMP
     DECLARE @SAL MONEY, @MIN MONEY = 0
     OPEN C1
     FETCH NEXT FROM C1 INTO @MIN
     WHILE ( @@FETCH_STATUS = 0 )
     BEGIN 
     FETCH NEXT FROM C1 INTO @SAL
     IF @SAL < @MIN
     SET @MIN = @SAL
     END
     PRINT @MIN
     CLOSE C1
     DEALLOCATE C1
   > Method 2
     DECLARE C1 CURSOR FOR SELECT SAL FROM EMP ORDER BY SAL ASC
     DECALRE @SAL MONEY 
     OPEN C1
     FETCH NEXT FROM C1 INTO @SAL
     PRINT @SAL
     CLOSE C1
     DEALLOCATE C1
 > Write a program to calcualte all the students total, avg, result and insert into result table
   > STUDENT
     SNO SNAME S1 S2 S3 
     1   A     80 90 70
     2   B     30 60 50
     RESULT 
     SNO TOTAL AVG RESULT
     
     > DECALRE C1 CURSOR FOR SELECT SNO, S1, S2, S3 FROM STUDENT
       DECLARE @SNO INT, @S1 INT, @S2 INT, @S3 INT
       DECALRE @TOTAL INT, @AVG DECIMAL(5,2), @ RES CHAR(4)
       OPEN C1
       FETCH NEXT FROM C1 INTO @SNO, @S1, @S2, S3
       WHILE ( @@FETCH_STATUS= 0 )
       BEGIN
       SET @TOTAL = @S1 + @S2 + @S3
       SET @AVG = @TOTAL/3
       IF @S1 >= 35 AND @S2 >= 35 AND @S3 >= 35
       SET @RES = 'PASS'
       ELSE 
       SET @RES = 'FAIL'
       INSERT INTO RESULT VALUES ( @SNO, @TOTAL, @AVG, @RES )
       FETCH NEXT FROM C1 INTO @SNO, @S1, @S2, @S3
       END 
       CLOSE C1
       DEALLOCATE C1 
 
 > Assignment
   ----------
   > RAISE_SALARY
     EMPNO PCT
     100   20
     101   25
     102   15
     103   10
     104   20
   > Write a program to increment employee salaries based on pct in raise_salary table
 
 > SCROLLABLE CURSOR
   -----------------
   > By default cursor is forward only cursor and forward only cursot supports forward
     navigation but doesn't support backward navigation.
   > If cursor declared with SCROLL then it is called scrollable cursor and it supports both forward and backward navigation
   > A Forward only cursor sypports FETCH NEXT statement but scrollable cursor supports the following fetch statements
     > FETCH FIRST       => Fetches first record
     > FETCH NEXT        => Fetches next record
     > FETCH PRIOR       => Fetches previous record
     > FETCH LAST        => Fetches last record
     > FETCH ABSOLUTE N  => Fetches Nth record from first record
     > FETCH RELATIVE N  => Fetches Nth record from current record
   > Examples
     > DECALRE C1 CURSOR SCROLL FOR SELECT ENAME FROM EMP
       DECLARE @NAME VARCHAR(10)
       OPEN C1
       FETCH FIRST FROM C1 INTO @NAME
       PRINT @NAME
       FETCH ABSOLUTE 5 FROM C1 INTO @NAME
       PRINT @NAME
       FETCH RELATIVE 5 FROM C1 INTO @NAME
       PRINT @NAME
       FETCH LAST FROM C1 INTO @NAME
       PRINT @NAME
       FETCH PRIOR FROM C1 INTO @NAME
       PRINT @NAME
       CLOSE C1 
       DEALLOCATE C1

     > Write a program to display every 5th record from EMP
       > DECLARE C1 CURSOR SCROLL FOR SELECT ENAME FROM EMP
         DECLARE @NAME VARCHAR(10)
         OPEN C1
         FETCH RELATIVE 5 FROM C1 INTO @NAME
         WHILE ( @@FETCH_STATUS=0 )
         BEGIN 
         PRINT @NAME
         FETCH RELATIVE 5 FROM C1 INTO @NAME
         END 
         CLOSE C1
         DEALLOCATE C1
     
     > Write a program to print names from last to first 
       > DECLARE C1 CURSOR SCROLL FOR SELECT ENAME FROM EMP
         DECLARE @NAME VARCHAR(10)
         OPEN C1
         FETCH LAST FROM C1 INTO @NAME
         WHILE (@@FETCH_STATUS=0)
         BEGIN 
         PRINT @NAME
         FETCH PRIOR FROM C1 INTO @NAME
         END 
         CLOSE C1 
         DEALLOCATE C1
     
     > Write a program to print 5th max salary
       > DECALRE C1 CURSOR SCROLL FOR SELECT DISTINCT SAL FROM EMP ORDER BY SAL DESC
         DECALRE @SAL MONEY 
         OPEN C1 
         FETCH ABSOLUTE 5 FROM C1 INTO @SAL
         PRINT @SAL
         CLOSE C1 
         DEALLOCATE C1
         
240623

 > ERROR Handling / EXCEPTION HANDLING
   -----------------------------------
   > Syntax errors
     Logical errors
     Runtime errors (exceptions)
   
   > Errors that are raised during program execution are called runtime errors
   > If any statement causes runtime error then SQL server displays error message 
     and continues program execution. To replace ssytem generated message with our 
     own simple and user friendly message then we need to handle that runtime error
   > To handle runtime error include a block called TRY---CATCH block
   > Syntax
     > BEGIN TRY 
       statement 1 
       statement 2  => statements causes exception
       statement 3
       statement 4 
       statement 5
       .
       .
       .
       END TRY 
       BEGIN CATCH   
       statements   => statements handles exception
       END CATCH
     > If any statement in TRY block causes runtime error then control transferred to catch block 
       and executes the statements in catch block 
   > Example
     > DECLARE @a TINYINT, @b TINYINT, @c TINYINT
       BEGIN TRY 
       SET @a = 100
       SET @b = 2000
       SET @v = @a/@b
       PRINT @c
       END TRY 
       BEGIN CATCH
       PRINT 'ERROR-------'
       END CATCH
       > OUTPUT
         > ERROR-------
   
   > ERROR HANDLING FUCNTIONS
     ------------------------
     > ERROR_NUMBER()    => Returns error code 
     > ERROR_MESSAGE()   => Returns error message
     > ERROR_SEVERITY()  => Returns error severity level
     > ERROR_STATE()     => Returns error state
     > ERROR_LINE()      => Returns error line number

     > Example
       > DECLARE @a TINYINT, @b TINYINT, @c TINYINT
        BEGIN TRY 
        SET @a = 100
        SET @b = 2000
        SET @v = @a/@b
        PRINT @c
        END TRY 
        BEGIN CATCH
        PRINT 'ERROR-------'
        END CATCH
        IF ERROR_NUMBER() = 220
        PRINT 'value should be between 0 and 255'
        ELSE IF ERROR_NUMBER() = 8134
        PRINT 'divisor cannot be zero'
        END CATCH
       
       > CREATE TABLE EMP99
         (
          EMPNO INT PRIMARY KEY,
          ENAME VARCHAR(10) NOT NULL,
          SAL MONEY CHECK(SAL>=3000),
          DNO INT REFERENCES DEPT(DEPTNO)
         )
         ALTER TABLE DEPT 
         ALTER COLUMN DEPTNO INT NOT NULL
         ALTER TABLE DEPT
         ADD PRIMARY KEY (DEPTNO)
         > Write a program to insert data into EMP99 table
           > DECALRE @ENO INT, @NAME VARCHAR(10), @SAL MONEY, @DNO INT
             BEGIN TRY
             SET @ENO = 100
             SET @NAME = 'A'
             SET @SAL = 3000
             SET @DNO = 10
             INSERT INTO EMP99 VALUES (@ENO, @NAME, @SAL, @DNO)
             END TRY
             BEGIN CATCH
             OF ERROR_NUMBER() = 2627
             PRINT 'Name should not be null'
             ELSE IF ERROR-NUMBER() = 515
             PRINT 'Name should not be null'
             ELSE IF ERROR-NUMBER() = 547
             PRINT 'sal >= 3000 or parent key not found'
             END CATCH

   > USER DEFINED ERRORS
     -------------------
     > Errors raised by user are called user defined errors
     > User defined errors are raised to stop program execution based on condition
     > Raised by using RAISERROR procedure
     > Syntax
       > RAISERROR(erorr message, severity level, state)
       > Severity level => 0 to 25
         > 0 to 11 => informational message 
         > 12 to 19 => errors
         > 20 to 25 => fatal errors
       > State => 0 to 255
         > Useful if same error raises in multiple locations
         > By using state we can identify which part of the program is causing error
         
260623

     > Examples
       > Write a program to increment an employee salary by specific amount
         but sunday updates are not allowed 
         > DECLARE @ENO INT, @AMT MONEY
           SET @ENO = 100
           SET @AMT = 1000
           IF DATENAME(DW, GETDATE()) = 'SUNDAY'
           RAISERROR( 'sunday not allowed', 15,1 )
           ELSE
           UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO = @ENO
       
       > ACCOUTNS
         ACCNO  ACTYP BAL
         100    S     10000
         101    S     20000
         Write a program to process money transfer 
         > DECALRE @SACNO INT, @TACNO INT, @AMT MONEY, @BAL MONEY
           DECLARE @MSG VARCHAR (100)
           SET @SACNO = 100
           SET @TACNO = 101
           SET @AMT = 1000
           IF EXISTS ( SELECT * FROM ACCOUNTS WHERE ACCNO = @SACNO )
           RAISERROR ( 'source account does not exist', 15, 1 )
           IF NOT EXISTS ( SELECT * FROM ACCOUTNS WHERE ACCNO = @TACNO )
           RAISERROR ( 'target accounts does not exist', 15, 1 )
           SELECT @BAL = BAL FROM ACCOUTNS WHERE ACCNO = @SACNO
           IF @AMT > @BAL
           RAISERROR ( 'insufficient balance', 15, 1 )
           UPDATE ACCOUTNS SET BAL = BAL - @AMT WHERE ACCNO = @SACNO
           UPDATE ACCOUTNS SET BAL = BAL + @AMT WHERE ACCNO = @ TACNO
           END TRY 
           BEGIN CATCH
           SET @MSG ERROR_MESSAGE()
           RAISERROR ( @MSG, 15, 1 )
           END CATCH

 =======================================================================================================================================

 > NAMED T-SQL BLOCKS :- 
  --------------------
   > 1 STORED PROCEDURES
     2 FUNCTIONS 
     3 TRIGGERS 

 > SUB-PROGRAMS
  -------------
  > 1  STORED PROCEDURES
    2  FUNCTIONS 

  > Advantages: 
   ----------
   > 1. Modular programming
     > With the help of procedures and functions a big T-SQL program can be divided into small modules
   > 2. Reusability
     > Procedures and functions are stored in DB, so applications which are connected to DB can reuse this programs
   > 3. Invoked from front-end applications
     > front applications like JAVA/.Net
   > 4. Security
     > Because there programs are stored in DB, so only authorized users can execute these programs
   > 5. Improves preformance
     > Procedures imporves performance because they are precompiled i.e., when we create a procedure program is compiled 
       and stored in DB and whenever we call only execution is repeated but not compilation, so this impoves performance.
 
 > STORED PROCEDURES
   -----------------
   > A stored procedure is a names T-SQL block that accepts some input performs some action on DB and may or may not returns a value
   > Procedures are created to perform one or more actions like insert, update, delete, select on DB
   > Syntax 
     > CREATE OR ALTER  PROCEDURE <NAME>
       parameters if any 
       AS
       STATEMENTS 

 > Parameters: 
   ----------
   > We can declare parameters and we can pass valeus to parameters
   > Parameters are 2 types 
     > INPUT ( DEFAULT )
     > OUTPUT
   > INPUT
     > Always recieves value
   > OUTPUT 
     > Always sends value
 
 > How to view/change STORED PROCEDURES
   ------------------------------------
     > DB ( right click )
       > PROGRAMMABILTY
         > Stored procedures
           > Modify

 > Examples (Procedures without parameters)
   > Create procedure to increment all employee salaries by 1000
     CREATE OR ALTER PROCEDURE raise_salary
     AS
     UPDATE EMP SET SAL = SAL + 1000

     procedure created ( compiled + stored in DB )

270623

 > EXECUTION
   ---------
   > Syntax example
     > EXECUTE raise_salary
   > Refer Calling procedure image file
   > Examples ( procedure with parameters)
     > Create procedure to increment specific employee sal by specific amount
       > CREATE OR ALTER PROCEDURE RAISE_SALARY
         @ENO INT, 
         @AMT MONEY
         AS 
         UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO = @ENO
         > EXECUTION
           > EXECUTE RAISE_SALARY_ 100, 1000              (postional association)  // method 1
           > EXECUTE RAISE_SALARY @ENO = 100, @AMT = 1000 (named association)  // method 2
           > EXECUTE RAISE_SALARY @AMT = 1000, @ENO = 100
  
       
     > Create procedure to increment specific employee sal by specific amount and after increment 
       send the updated sal to calling program
       > CREATE OR ALTER PROCEDURE RAISE_SALARY
         @ENO INT,
         @AMT MONEY,
         @NEWSAL MONEY OUTPUT
         AS
         UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO = @ENO
         SELECT @NEWSAL = SAL FROM EMP WHERE EMPNO = @ENO
         > EXECUTION
           > DECLARE @S MONEY
             EXECUTE RAISE_SALARY 100,1000, @S OUTPUT
              PRINT @S                                  // positional
            
             > DECLARE @S MONEY
              EXECUTE RAISE_SALARY @ENO = 100, @AMT = 1000, @NEWSAL = @S OUTPUT
              PRINT @S                                  // named
 
     > Example: Parameters with default values
       > A parameter can be decalred with default value as follows
         @AMT MONEY = 500
       > While calling procedure, if we don't pass value to parameter then SQL Server assigns default value 
          > CREATE OR ALTER PROCEDURE RAISE_SALARY
           @ENO INT
           @AMT MONEY = 500
            @NEWSAL MONEY OUTPUT
           AS
            UPDATE EMP SET SAL = SAL + @AMT WHERE EMPNO = @ENO
            SELECT @NEWSAL = SAL FROM EMP WHERE EMPNO = @ENO
           > Execution
             > DECLARE @S MONEY
               EXECUTE RAISE_SALARY 100, DEFAULT, @S OUTPUT
                PRINT @S
    
                DECLARE @S MONEY
                EXECUTE RAISE_SALARY @ENO = 100, @NEWSAL = @S OUTPUT
                PRINT @S
       
     > CREATE TABLE CUST
       (
        CUSTID INT PRIMARY KEY,
        CNAME VARCHAR(10) NOT NULL,
        EMAILID VARCHAR(20) UNIQUE,
        AGE INT CHECK(AGE>=20)
       )
       > Create a procedure to insert data into CUST table
         > CREATE OR ALTER PROCEDURE INSERT_NEW_CUST
           @CID INT, 
           @NAME VARCHAR(10),
           @EMAILID VARCHAR(20),
           @AGE INT
           AS
           DECALRE @MSG VARCHAR(100)
           BEGIN TRY
           INSERT INTO CUST VALUES (@CID, @NAME, @EMAILID, @AGE)
           END TRY
           BEGIN CATCH
           BEGIN CATCH 
           SET @MSG = ERROR_MESSAGE()
           RAISERROR(@MSG, 15, 1)
           END CATCH
           > EXECUTION
             EXECUTE INSERT_NEW_CUST 100, 'A', 'abc@gmail.com', 30
     
     > ACCOUNTS
       ACCNO ACTYPE BAL
       100   S      10000
       101   S      20000

       TRANSACTIONS
       TRID  TTYPE  TDATE  TAMT  ACCNO

       CREATE TABLE ACCOUNTS
       (
        ACCNO PRIMARY KEY,
        ACTYPE CAHR(1),
        BAL MONEY
       )

       CREATE TABLE TRANSACTIONS
       (
        TRID INT IDENTITY,
        TTYPE CHAR(1) CHECK(TTYPE IN ('W', 'D')),
        TDATE DATETIME DEFAULT GETDATE(),
        TAMT MONEY,
        ACCNO INT REFERENCES ACCOUNTS(ACCNO)
       )

       INSERT INTO ACCOUNTS VALUES (100,'S',10000), (101,'S',20000)
       > Create procedure foe money withdrawl
         > CREATE OR ALTER PROCEDURE DEBIT
           @ACNO INT,
           @AMT MONEY,
           @NEWBAL MONEY OUTPUT
           AS
           DECLARE @BAL MONEY
           BEGIN TRY
           IF NOT EXISTS (SELECT * FROM ACCOUNTS WHERE ACCNO = @ACNO)
           RAISERROR('invalid accno',15,1)
           SELECT @BAL = BAL FROM ACCOUTNS WHERE ACCNO = @ACNO
           IF @AMT > @BAL
           RAISERROR('insufficient balance', 15, 1)
           UPDATE ACCOUNTS SET BAL = BAL - @AMT WHERE ACCNO = @ACNO
           INSERT INTO TRANSACTIONS ( TTYPE, TAMT, ACCNO ) VALUES ( 'W', @AMT, @ACNO )
           SELECT @NEWBAL = BAL FROM ACCOUNTS WHERE ACCNO = @ACNO
           END TRY
           BEGIN CATCH
           SET @MSG = ERROR_MESSAGE()
           RAISERROR ( @MSG, 15, 1)
           END CATCH

280623

 > Assignment
   ----------
   > Create procedure for moeny deposit
   > Create procedure for moeny transfer 
 
 > PROCEDURES RETURNING RECORDS
   ----------------------------
   > To return records from procedure take output parameter of cursor type
   > Example
     > Create procedure to accept deptno and returns list of employees working for that dept
       > CREATE OR ALTER PROCEDURE getEmpList
         @DNO INT,
         @curEMP CURSOR VARYING OUPUT
         AS
         SET @curEmp = CURSOR FOR SELECT EMPNO, ENAME, SAL FROM EMP WHERE DEPTNO = @DNO
         OPEN @curEMP
         > EXECUTION
           > DECLARE @c1 CURSOR, @ENO INT, @NAME VARCHAR(10), @SAL MONEY
             EXECUTE getEMPLIST @DNO = 30, @curEMP = @c1 OUTPUT
             WHILE (@@FETCH_STATUS = 0)
             BEGIN 
             PRINT CAST(@ENO AS VARCHAR) + '' + @NAME + '' + CAST(@SAL AS VARCHAR)
             FETCH NEXT FROM @c1 INTO @ENO, @NAME, @SAL
             END
             CLOSE @c1
             DEALLOCATE @c1

 > USER DEFINED FUNCTIONS
   ----------------------
   > When predefined funcrtions not meeting our requirements then we create our own fucntions
     called user define functions
   > A function accepts some input preforms some calculation and must return a value
   > Functions are of two types
     > Scalar valued 
     > Table valued
   > Scalar valued functions
     -----------------------
     > These functions accpets one or more values and returns one value
     > Return type of these fucntions must be scalr types like int, varchar etc
     > Return expression must be a scalar variable
     > Syntax
       > CREATE OR ALTER 
         FUNCTION <name> ( parameters if any ) RETURNS <type>
         AS
         BEGIN
         STATEMENTS
         RETURN <expr>
         END
     > Example
       > CREATE OR ALTER FUCTION 
         FUCNTION CALC ( @a INT, @b INT, @op CHAR(1)) RETURNS INT
         AS
         BEGIN
         DECALRE @c INT
         IF @op = '+'
         SET @c = @a + @b
         ELSE IF @op = '-'
         SET @c = @a - @b
         ELSE IF @op = '*'
         SET @c = @a * @b
         ELSE 
         SET @c = @a/@b
         RETURN @c
         END
         > Execution
           > SELECT DBO.CALC( 10, 20, '*' )
             > Output 200
       
       > Create a function that accepts deptno and returns names of the 
         employees working for that dept as follows
         > input: Deptno = 20
           output: SMITH, JONES, SCOTT, ADAMS, FORD
           > CREATE OR ALTER
             FUNCTION getNames(@dno INT) RETURNS VARCHAR(500)
             AS
             BEGIN
             DECLARE C1 CURSOR FOR
             SELECT ENAME FROM EMP WHERE DEPTNO = @dno 
             DECLARE @NAME VARCHAR(10), @S VARCHAR(500) = ''
             OPEN C1
             FETCH NEXT FROM C1 INTO @NAME
             WHILE(@@FETCH_STATUS = 0)
             BEGIN
             SET @S = @S + @NAME + ','
             FETCH NEXT FROM C1 INTO @NAME
             END 
             CLOSE C1
             DEALLOCATE C1
             RETURN STUFF(@S, LEN(@S),1,'') // to remove last ','
             END
             > EXECUTION
               > SELECT DBO.GETNAME(20) gives SMITH, JONES, SCOTT, ADAMS, FORD
       
       > Display DEPT wise EMPLOYEE names
         > 10 --,--,--
           20 --,--,---
           30 --,--,---
           SELECT DEPTNO, DBO.GETNAMES(DEPTNO) AS NAMES
           FROM EMP
           GROUP BY DEPTNO
 
 > STRING_AGG()
   ------------
   > Built-in function introduced in 2017 version and used to concatenate column values.
   > Syntax:
     > STRING_AGG(colname, seperator)
   > Example
     > SELECT STRING_AGG(ENAME,',') FROM EMP
     > SEELCT DEPTNO, STRING_AGG(ENAME, ',') AS NAMES 
       FROM EMP
       GROUP BY DEPTNO
       
300623

 > Create trigger to not allow DMLS on EMP table before 10am and after 4pm
   > CREATE OR ALTER TRIGGER T2
     ON EMP 
     AFTER INSERT, UPDATE, DELETE
     AS
     IF DATEPAR(HH,GETDATE()) < 10 OR DATEPART(HH,GETDATE()) > 16
     BEGIN 
     ROLLBACK
     RAISERROR('only betwen 10am abd 4pm',15,1)
     END

 > Create trigger to not allow DMLs on EMP table as follows
   > MON - FRI <10AM AND >4PM
     SAT       <10AM AND >2PM
     SUN       --------------

 > Create trigger to not allow to update EMPNO
   > CREATE OR ALTER TRIGGER T2
     ON EMP
     AFTER UPDATE
     AS
     ROLLBACK
     RAISERROR('empno cannot be updated',15,1)
     END
     > Testing
       > UPDATE EMP SET EMPNO = 999 WHERE EMPNO = 101 => Error

 > Magic Tables:
   ------------
   > 1 INSERTED
     2 DELETED
   
   > These talbes are called magic tables because they are collected and destroyed automatically
   > Using these tables we can access data effected by DML in triggers
   > These talbes exists during trigger execution
   > Record we try to insert is copied to INSERTED table
   > The record we try to delete is copied to DELETED table
   > The record we try to update is copied to bothe INSERTED & DELTED tables

   > Syntax example
     > INSERT INTO EMP VALUES(100,'A','CLERK',4000)
       INSERTED 
       EMPNO ENAME JOB   SAL
       100   A     CLERK 4000
     > UPDATE EMP SET SAL= 5000 WHERE EMPNO = 100
       INSERTED
       EMPNO SAL
       100   5000
       DELETED 
       EMPNO SAL
       100   4000
     > DELETE FROM EMP WHERE EMPNO = 100 
       DELETED 
       EMPNO ENAME JOB   SAL
       100   A     CLERK 5000

   > Example
     > Create trigger to not to allow to decrement salary
       > CREATE OR ALTER TRIGGER T4
         ON EMP
         ALTER UPDATE
         AS
         DECALARE @OLDSAL MONEY, @NEWSAL MONEY
         SELECT @OLDSAL = SAL FROM DELETED
         SELECT @NEWSAL = SAL FROM INSERTED
         IF @NEWSAL < @OLDSAL
         BEGIN
         ROLLBACK
         RAISERROR('sal cannot be decremented',15,1)
         END
         > Testing
           > UPDATE EMP SET SAL = SAL - 1000 WHERE EMPNO = 100 => ERROR

     > Create trigger to insert details into EMP_RESIGN table when employee resigns
       > EMP_RESIGN 
         EMPNO 
         CREATE TABLE EMO_RESIGN
         (
          EMPNO  INT,
          ENAME  VARCHAR(10),
          HIREDATE DATE,
          DOR DATE
         )

         CREATE OR ALTER TRIGGER T5
         ON EMP 
         AFTER DELETE 
         AS
         DECALRE @ENO INT, @NAME VARCHAR(10), @HIRE DATE
         SELECT @ENO = EMPNO, @NAME = ENAME, @HIRE = HIREDATE FROM DELETED
         INSERT INTO EMO_REDIGN VALUES(@ENO, @NAME, @HIRE, GETDATE())
         > Testing
           > DELETE FROM EMP WHERE EMPNO = 100 gives DELETED
             SELECT * FROM EMP_RESIGN
             100  SMITH  1980-12-17  2023-06-30
 
 > INSTEAD OF triggers:
   --------------------
   > If trigger is instead of then SQL Server executes the trigger instead of executing DML
   > DML is replaced with trigger 
   > Example
     > Create trigger to not allow more than 4 employees per department
       > EMP123
         ENO ENAME DNO
         1   A     10
         2   B     10
         3   C     10
         4   D     10
         5   E     10 gives INVALID
         > CREATE TABLE EMP123
           (
            ENO INT,
            ENAME VARCHAR(10),
            DNO INT
           )

           CREATE OR ALTER TRIGGER T6
           ON EMP123
           INSTEAD OF INSERT
           AS
           DECLARE @ENO INT, @NAME VARCHAR(10), @DNO INT
           SELECT @ENO = ENO, @NAME = ENAME, @DNO = DNO FROM INSERTED
           SELECT @CNT = COUNT(*) FROM EMP123 WHERE DNO = @DNO
           IF @CNT = 4
           RAISERROR('max 4 emps per dept', 15,1)
           ELSE
           INSERT INTO EMP123 VALUES(@ENO, @NAME, @DNO)

           > Testing
             -------
             > INSERT INTO EMP123 VALUES(1,'A',10)
               INSERT INTO EMP123 VALUES(2,'B',10)
               INSERT INTO EMP123 VALUES(3,'C',10)
               INSERT INTO EMP123 VALUES(4,'D',10)
               INSERT INTO EMP123 VALUES(5,'E',10) gives error

 > ALTER trigger
   > IF COND
     BEGIN
     ROLLBACK
     RAISERROR
     END

 > INSTEAD OF trigger
   > IF COND
     RAISERROR
     ELSE 
     DML
     
010723

 > Dynamic SQL
   -----------
   > SQL commands generated at runtime 
   > Examples
     > DROP TABLEMP (static SQL)
     > DECALRE @TNAME VARCHAR(10)
       SET @TNAME = 'EMP'
       DROP TABLE @TNAME (dynamic SQL)
   > Dynamic SQL is useful when we don't know tablenames and column names until runtime
   > Dynamic SQL commands are executed using EXEC
     EXEC ('Dynamic SQL command')
   > Example
     > Create a procedure to drop table from DB
       > CREATE OR ALTER PROCEDURE DROP_TABLE
         @TNAME VARCHAR(20)
         AS
         EXEC ('DROP TABLE ' + @TNAME)
         Execution
         > EXECUTE DROP_TABLE 'CUST' gives "Commands comepleted successfully"  // Table is dropped
           SELECT * FROM 'CUST'
     
     > Create a procedure to drop all the tables from DB
       > SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES         //gives list of tables and views
         WHERE TABLE_TYPE = 'BASE TABLE'                          //gives list of tables
         
         CREATE OR ALTER PROCEDURE DROP_ALL_TABLES
         AS
         DECALRE C1 CURSOR FOR SELECT TABLE_NAME
         FROM INFORMATION_SCHEMA.TABLES
         WHERE TABLE_TYPE = 'BASE TABLE'
         DECLARE @TNAME VARCHAR(100)
         OPEN C1
         FETCH NEXT FROM C1 INTO @TNAME
         WHILE (@@FETCH_STATUS=0)
         BEGIN
         EXEC('DROP TABLE' + @TNAME)
         FETCH NEXT FROM C1 INTO @TNAME
         END
         CLOSE C1
         DEALLOCATE C1
         > Execution
           > EXECUTE DROP_ALL_TABLES  // referenced tables by some foreign key table cannot be dropped, 
           table name which is not following the rules(not starting with alphabets) should be mentioned in [] like Drop table [123]
    
 > Temporary Tables
   ----------------
   > They exist only upto the session and once session is closed these are destroyed
   > Created to store data temporaryly
   > Temporary Tables are 2 types
     > Local Temporary Tables
     > Global Temporary Tables

   > Local Temporary Tables
     ----------------------
     > These tables can be accessed only with in the 
       session where it is created and cannot be accessed in another session
     > Example synatax
       > CREATE TABLE #TEMP   // prefix table with '#'
         (
          EMPNO INT, 
          ENAME VARCHAR(10),
          SAL MONEY
         )

         INSERT INTO #TEMP
         SELECT EMPNO, ENAME, SAL FROM EMP

         SELECT * FROM #TEMP
   
 > Global Temporary table
   ----------------------
   > These tables are created in 1 session and can be accessed in another session
    > CREATE TABLE ##TEMP
      (
       EMPNO INT,
       ENAME VARCHAR(10),
       SAL MONEY
      )
      INSERT INTO ##TEMP
      SELECT EMPNO, ENAME, SAL FROM EMP
     Method 2
      SELECT * INTO ##TEMP FROM EMP
       
    > Global temporary table is destroyed automatically when the session in which it
      is creted is closed

 > Table variables
   ---------------
   > The table variable is a special type of the variable that helps to store date temporarily,
     similar to the temp table in SQL Server
   > Table variables exists upto the program execution, once program execution
     is completed then table variables are destroyed automatically
   > Syntax
     > DECLARE @VARNAME TABLE
       ( 
        COL1 DATATYPE(SIZE),
        COL2 DATATYPE(SIZE),
        .
        .
        .
        .
       )
   > Example
     > DECLARE @EMP TABLE 
       (
        EMPNO INT,
        ENAME VARCHAR(10),
        SAL MONEY
       )
       INSERT INTO @EMP 
       SELECT EMPNO, ENAME, SAL FROM EMP
       
       SELECT * FROM @EMP

020723

 > Backup & Restore
   ----------------
   > DB must be protected from various failures like hardware, software, program etc.
   > Backups are created to protect data from failure
   > Copying data from db to .bak file is called Backup
   > Recovering db from backup is called restore
   
   > How to take backup
     ------------------
     > DB (rightclick)
       > Back Up Database
         > Backup type: Full ( everything )
                        Differential ( Only changes from last baclup )
                        
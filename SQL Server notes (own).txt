Downloading & installation :- 
 -------------------------------------
     
 downloading sql server :- 
 -----------------------------------

 https://www.microsoft.com/en-in/sql-server/sql-server-downloads

 step by step installation of sql server 2022 :- 
 ---------------------------------------------------------

 https://www.sqlshack.com/how-to-install-sql-server-developer-edition/

 download ssms :- 
 --------------------------

 https://learn.microsoft.com/en-us/sql/ssms/download-sql-server-management-studio-ssms?view=sql-server-ver16

Creating new DB
===============
 After loggin
 >Right click on Databases
  >New Database 
   > (two files are created, one is data file .MDF and one is log file .LDF )

 To find it in explorer (to find files in your system)
 ----------------------
 >Programfiles
  >Microsoft SQL Server
   >MSSQL 15.MSSQLSERVER
    >MSSQL
     >DATA
      >(your created DB)

Datatypes
=========
 >CHAR
  >ASCII // char/varchar allows ascii characters (256 characters) that includes a-z, A-Z, 0-9, special characters, i.e., char/varchar allows alphanumeric
   Examples: PANNO CHAR(10), VEHNO CHAR(10), EMAIL VARCHAR(20)

   >char //allows character data upto 8000 characters,
    recommended for fixed length character columns. 
    Example: NAME CHAR(10) here name can be upto 10 characters,
    in char data type extra bytes are wasted, 
    so char is not recommended for variable length fields 
    and is recommended for fixed length fields.
    Example: GENDER CHAR(1) M F , STATE_CODE CHAR(2) AP TS MH, COUNTRY_CODE CHAR(3) IND USA 
               
   >varchar //for variable length use varchar, allows character data upto 8000.
    Example: NAME VARCHAR(10) SACHIN here extra bytes i.e., 4 bytes are released and 
    allocated to other data

   >varchar(max) //to store more than 8000 characters use varchar(max), upto 2GB, 

  >UNICODE // allows unicode characters (65536 characters),
   that includes characters of diff languages.
   >nchar
   >nvarchar
   >nvarchar(max)

 >INTEGER // allows numbers without decimal part
   >tinyint // 1 byte, value between 0 to 255, Examples: AGE
   >smallint // 2 bytes, value between -32768 to 32768, Examples: EMPID
   >int // 4 bytes, value between -2147483648 to 2147483647
   >bigint // 8 bytes, valid number between -9223372036854775808 to 9223372036854775807

   >numberic(p) // allows numbers upto 38 digits, Examples: EMPID NUMERIC(4) here maximum 
    four digits are allowed like 10, 100, 1000, 2000 but 10000 which is 5 characters not allowed
    AADHARNO NUMERIC(12), ACCNO NUMERIC(13), MOBILE NUMERIC(10)

 >FLOAT
   >numeric(p,s) or decimal(p,s) // allows numbers with decimal (float).
    here P means precision that is total number of digits, 
    S means scale that is number of digits after decimal.
    Examples: SAlARY NUMERIC(7,2) like 10000.50 is valid 500000.60 is invalid, 

 >CURRENCY // used for fields related to money
   >smallmoney // 4 bytes, range is -214748.3648 to 214748.3647
   >money // 8 bytes, range is -922337203685477.5808 to 922337203685477.5807
   Exmaples: SAL SMALLMONEY, BAL MONEY

 >DATE 
   >date // only date
   >time // only time
   >datetime // allows date and time
  Defalut date format for SQL Server is YYYY-MM-DD
  Default time format for SQL Server is HH:MM:SS
  Example: DOB DATE, LOGIN TIME, TXNDT DATETIME gives like 2023-05-11 9:30:00

 >BINARY // allows mutimedia objects like audio, video, images
   >binary // allows upto 8000 bytes
   >varbinary // allows upto 8000 bytes
   >varbinary(max) // allows upto 2GB
  Example: photo BINARY(1000) here 1000 bytes allocated for photo and extra bytes are wasted.
  photo VARBINARY(1000) here extra bytes are released
 

   
To Work with Database
=====================
 >Right click on Databases
  >New Querry // Querry window opens

Creating TABLE 
==============
 > Tablename should start with alphabet, no spaces, only _ $ # are allowed,
   can be upto 128 characters, can have 1024 columns, unlimited rows
   Examples: 123EMPID invalid, EMP 123 INVALID, EMP*123 INVALID, EMP_123 VALID

 CREATE TABLE EMP
 (
 EMPID SMALLINT,
 ENAME VARCHAR(10),
 JOB VARCHAR(10),
 SAL SMALLMONEY,
 HIREDATE DATE,
 DNO TINYINT
 )

 > To check exiting Datatypes
   > SP_HELP

To Display table information
============================
 > SELECT * FROM <tablename> 
   > here from above table its SELECT * FROM EMP

Inserting Date into table
=========================
 > "INSERT" command for inserting data
   > we can insert single row or multiple rows

   > Inserting single row
     --------------------
    > INSERT INTO <TABLENAME> VALUES(V1, V2, V3, V4, V5, V6,.....)
    Examples:
     > INSERT INTO EMP VALUES(100,'SACHIN','CLERK',5000,'2023-05-11',10)
     > INSERT INTO EMP VALUES(101,'VIJAY','ANALYST',8000,getdate(),20) // getdate() returns that current days date

   > Inserting multiple rows
     -----------------------
     > INSERT INTO EMP VALUES(102,'PHANI','MANAGER',9000,'2019-10-05',30),(103,'SINDHU','ANALYST',7000,'2021-04-20',20)

   > Inserting blanks 'null' values (empty) // not equal to 0 or space
     --------------------------------------
     > Nulls can be inserted in two ways
     > Method 1: INSERT INTO EMP VALUES(104,'KUMAR',null,3000,'2020-02-15',null)
     > Method 2: INSERT INTO EMP(EMPID,ENAME,SAL,HIREDATE) VALUES(105,'JAMES',5000,getdate()) // remaining fields job,dno filled with nulls



120523

 Operators in SQL Server
 =======================

 + - * / % for calculation
 gives value as output

 Relational operators in SQL Server
 ==================================

 => > >= < <= = <> or !=
 gives True/False as output

 10 > 5 True
 10 < 5 False
 10 = 5 False
 10 <> 5 True ~ 10 != 5 True

 Logical Operators in SQL Server
 ===============================

 AND OR NOT

 Special Operators in SQL Server
 ===============================

 BETWEEN
 IN
 LIKE
 IS
 ANY
 ALL
 EXITS

 Set Operators in SQL Server
 ===========================

 UNION
 UNION ALL
 INTERSECT
 EXCEPT

 Display Data in SQL Server
 ==========================
 
 > "SELECT" command is used to display data from the table.

 syn: SELECT <col/*> FROM <tabname>; // this whole statement is called querry or command and SELECT and FROM  are called clauses

 SQL = English
 QUERIES = Sentences
 CLAUSES = Words

 FROM clause -> specify tablename
 SELECT clause -> specify column names
 * -> all columns

 > Display employee names and salaries/hiredate/dno
 SELECT ENAME,SAL FROM EMP
 SELECT ENAME,HIREDATE FROM EMP
 SELECT ENAME,DNO FROM EMP

 > Display all the data from EMP
   Syntax:
     SELECT * FROM EMP //shows all the data

 > WHERE caluse: ( Display specific )
   ===============
   Used to access specific row/rows based on a condition

 SELECT columns
 FROM tabname
 WHERE condition

 conditions: ( made of relational operators )
  COLNAME OP VALUE
   > OP is any relational operator like > >= < <= = <>
   > if cond is true row is selected
   > if cond is false row is not selected
 Examples:
 ---------
  Display employee details whose id = 102
  > SELECT * FROM EMP WHERE EMPID=102 // goes every row and checks true or false and shows all the datails because '*'
  > SELECT ENAME FROM EMP WHERE EMPID=102 //only name will be shown here 
  Display employee details whose name = 'Kumar'
  > SELECT * FROM EMP WHERE ENAME = 'Kumar' // '' mandatory to display sting
  Display employee details who earn more then 5000
  > SELECT * FROM EMP WHERE SAL > 5000
  Display employees joined after 2020
  > SELECT * FROM EMP WHERE HIREDATE > 2020 // date is incompatable with number
  > SELECT * FROM EMP WHERE HIREDATE > '2020-12-31' // Hiredate date type is compated with '2020-12-31' which is also date type
  Display employees joined before 2020
  > SELECT * FROM EMP WHERE HIREDATE < '2020-01-01'
  Display employees not working for Dno 10
  > SELECT * FROM EMP WHERE DNO <> 10

 Adding multiple condtions to single querry
 Compound condtion:
 ==================
 Multilple condtions combined with AND / OR operators is called compound condtion.
 > WHERE COND1 AND/OR COND2 
 Examples:
 ---------
  > WHERE CATEGORY = 'MOBILES' AND PRICE < 20000 // only mobiles under 20000
  > WHERE CATEGORY = 'MOBILES' OR PRICE < 20000 // any product that is under 20000, satisfying one condtion is enough
  Display Employee details whose id = 100, 103, 105
  > SELECT * FROM EMP WHERE EMPID = 100 OR EMPID = 103 OR EMPID = 105
  Display employees working as clerk, analyst
  > SELECT * FROM EMP WHERE JOB = 'CLERK' OR JOB = 'ANALYST'
  Display employees working as analyst beloging to 20th Dept
  > SELECT * FROM EMP WHERE JOB = 'ANALYST' AND DNO = '20'
  Display employees earning >5000 and <10000
  > SELECT * FROM EMP WHERE SAL > 5000 AND SAL < 10000
  Display employees joined in 2020
  > SELECT * FROM EMP WHERE HIREDATE >= '2020-01-01' AND HIREDATE <= '2020-12-31'
  Display employees working as clerk, analyst and earning more than 5000
  > SELECT * FROM EMP WHERE JOB = 'CLERK' OR JOB = 'ANALYST' AND SAL > 5000 // here JOB = 'ANALYST' AND SAL = 5000 are compared first i.e AND is prioritized and then it'll compare with JOB = 'CLERK'
  > SELECT * FROM EMP WHERE ( JOB = 'CLERK' OR JOB = 'ANALYST' ) AND SAL > 5000 // () to force comparision
    
130523

  IN Operator
  ===========
   >Use IN operator for comparision with list.
    >List is like 10, 20, 30, 40...
   >Use IN operator for "=" comparision with multiple values.
    > WHERE COLNAME = V1,V2,V3... //is invalid, = cannot be used with multiple values
    > WHERE COLNAME IN(V1,V2,V3...) //is valid, if you want to use = with multiple values

    >Display employees whose id = 100,103,105
      > SELECT * FROM EMP WHERE EMPID IN (100,103,105) //Old WHERE EMPID = 100 OR EMPID = 103 OR EMPID =105
    >Display employees working as clerk, manger
     > SELECT * FROM EMP WHERE JOB IN ('CLERK', 'MANAGER')
    >Display employees not working for deptno 10,20
     > SELECT * FROM EMP WHERE DNO NOT IN (10,20)

  WHERE Operator
  ==============
   >Use BETWEEN operator for comeparision with range
    >like 10 to 50 is called range ( all the values between 10 and 50 are included i.e., 10,11,12,.....48,49,50)
    > WHERE COLNAME BETWEEN V1 AND V2 // is equivalent to COL>=V1 AND COL<=V2

    >Display the employees earning between 5000 and 10000
     > SELECT * FROM EMP WHERE SAL BETWEEN 5000 AND 10000 //always use BETWEEN with lower limit and Upper limit
    >Display the employees joined in 2020 year
     > SELECT * FROM EMP WHERE HIREDATE BETWEEN '2020-01-01' AND '2020-12-31'
    >Display the employees not joined in 2020 year
     > SELECT * FROM EMP WHERE HIREDATE NOT BETWEEN '2020-01-01' AND '2020-12-31'
    >Display the employees working as Clerk, manager and earning between 5000 and 10000 and joined in 2019 and not working for deptno 10,20
     > SELECT * FROM EMP WHERE JOB IN ('CLERK', 'MANAGER') AND SAL BETWEEN 5000 AND 10000 AND HIREDATE BETWEEN '2019-01-01' AND '2019-12-31' AND DNO NOT IN (10,20)
    
    PRODUCTS
    PRODID PNAME PRICE CATEGORY BRAND
    
    >Display list of Samsung, Redmi, Realme mobile phones between 10000 and 20000
     > SELECT * FROM PRODUCTS WHERE CATEGORY = 'MOBILES' AND BRAND IN ('SAMSUNG', 'REDMI', 'REALME') AND PRICE BETWEEN 10000 AND 20000
    
    CUSTOMERS
    CID NAME CITY AGE GENDER

    >Display the list of male customers staying in HYD, MUM, DEL aged between 20 and 30
     > SELECT * FROM CUSTOMERS WHERE GENDER = 'MALE' AND CITY IN ('HYD', 'MUM', 'DEL') AND AGE BETWEEN 20 AND 30

  LIKE Operator
  =============

   >Use LIKE operator for comparision of patterns
    > WHERE COLNAME LIKE 'PATTERN'
   >Pattern contains alphabets, digits, wildcard characters

   >Wildcard characters
    --------------------
    > % => 0 or many characters
    > _ => exactly 1 characters

    >Display employees with name starting with 'S' // remaining characters we don't know
     > SELECT * FROM EMP WHRE ENAME LIKE 'S%'
    >Display employees with name ending with 'S'
     > SELECT * FROM EMP WHERE ENAME LIKE '%S'
    >Display employees with name containing 'A'
     > SELECT * FROM EMP WHERE ENAME LIKE '%A%'
    >Display employees with 'A' is the 3rd character of their name
     > SELECT * FROM EMP WHERE ENAME LIKE '__A%' // two underscores before A
    >Display employees with 'A' is the 3rd character of their name from last 
     > SELECT * FROM EMP WHERE ENAME LIKE '%A__' // two underscores after A
    >Display employees with name containing 4 characters
     > SELECT * FROM EMP WHERE ENAME LIKE '____' // four underscores, each underscore is equal to one character
    >Display employees joined in Feb month
     > SELECT * FROM EMP WHERE HIREDATE LIKE '_____02___' // date format is YYYY-MM-DD , %02% does not give only feb but also take dates like 2002-10-15, 2020-02-10, 2023-01-02 it may be month year or day, by giving _____02___ we're forcing SQL to consider it as month
    >Display employees joined in 2020 year
     > SELECT * FROM EMP WHERE HIREDATE LIKE '2020%' // % replaces -MM-DD or use 6 underscores after 2020

150323

 IS Operator 
 ===========
   > For comparision with NULL/ NOT NULL
     > WHERE COLNAME IS NULL
     > WHERE COLNAME IS NOT NULL // NULL cannot be compared with = , must be compared with IS Operator

     > Display empleyees not assigened to any dept
       > SELECT * FROM EMP WHERE DNO IS NULL
     > Display empleyees not assigened to any job
       > SELECT * FROM EMP WHERE JOB IS NULL
     > Display empleyees who are assigened to any dept
       > SELECT * FROM EMP WHERE DNO IS NOT NULL
 
 Summary:
 --------
   WHERE COLNAME IN (V1,V2,V3,V4,V5,V6....)
   WHERE COLNAME BETWEEN V1 AND V2
   WHERE COLNAME LIKE 'PATTERN'
   WHERE COLNAME IS NULL

 Examples:

  STUDENT
  SID SNAME S1 S2 S3
  1   A     80 90 70
  2   B     30 60 50

   > Display list of students who are passed
     > SELECT * FROM STUDENT WHERE S1>=35 AND S2>=35 AND S3>=35
   > Display list of students who are failed
     > SELECT * FROM STUDENT WHERE S1<35 OR S2<35 OR S3<35
  
  CREATE INSERTING DATA Another method ( UI Method)
  =============================
    > Select DB ( your created)
     > right click on table
       > new table
         > click save after entering data
         > Table created

    > Right click on table
      > Edit     

 > ALIAS:
  =======
   > Alias means another name
   > Used to change column headings
   > Syntax: COLNAME / EXPRESSION AS <ALIAS>
   > Examples: // In SELECT on column headings and arthematic calculations are allowed
     > Display ENAME ANNUAL SAlARY
       >SELECT ENAME,SAL*12 AS [ANNUAL SALARY] // name should not contain space, keep it in [] / "" to make it exceptional
     > Display a Table named 123 and (A INT, B INT, C INT)
       > CREATE TABLE [123](A INT, B INT, C INT)
     > Display a Table with ENAME SAL DA TAX TOTSAL
       > HRA House Rent Allowance, take it 20% on sal 
       > DA Dearness Allowance, take it 30% on sal
       > TAX is tax, take it as 10% on sal
       > TOTSAL is SAL+HRA+DA-TAX
       > SELECT ENAME,SAL,SAL*0.2 AS HRA,SAL*0.3 AS DA,SAL*0.1 AS TAX,SAL + (SAL*0.2) + (SAL*0.3) - (SAL*0.1) AS TOTSAL FROM EMP

 > ORDER BY Clause:
  =================
   > Used to sort rows based on one or more columns 
     either in ascending or descending order.
   > SELECT columns FROM tabname [WHERE condition] ORDER BY colname ASC/DESC, ...
   > Default order is ASC for descending order use DESC option
   > Examples:
     > Arrange Employee list name wise asc order 
       > SELECT * FROM EMP ORDER BY ENAME ASC 
     > Arrange Employee list salary wise descending order
       > SELECT * FROM EMP ORDER BY SAL DESC
     > Arrange Employee list dept wise ascending order and with in dept sal wise descending
       > SELECT * FROM EMPNO,ENAME,SAL,DEPTNO FROM EMP ORDER BY DEPTNO ASC, SAL DESC

160523
 
 To delete the table
  > DROP TABLE <tablename>

 Examples:
 ---------
  > STUDENT
    SNO SNAME M  P  C
    1   A     80 90 70
    2   B     60 70 50
    3   C     90 80 70
    4   D     90 70 80
   > Arrange student list average wise descending order, m descending order, p descending order
     > SELECT * FROM STUDENTS ORDER BY (M+P+C)/3 DESC,M DESC,P DESC 
     > but to display average in output SELECT *, (M+P+C)/3 AS AVG FROM STUDENTS ORDER BY (M+P+C)/3 DESC,M DESC,P DESC


  > Display empleyees working as Clerk, manager and arrange list sal wise descending orderorder
   > SELECT EMPNO,ENAME,JOB,SAL FROM EMP WHERE JOB IN ('CLERK','MANAGER') ORDER BY SAL DESC
  
  > Note: Nulls are considered as low in sorting
    > like in ascending order nulls are arranged first and viseversa for descending order.

 DISTINCT clause:
 ----------------
   > ELeminates duplicates from select statement output
   > Syntax
     > DISTINCT col
     > DISTINCT col1,dol2,...
     > DISTINCT *

   > Example
     > SELECT DISTINCT JOB FROM EMP ANALYST CLERK MANAGER PRESIDENT SALESMAN
     > SELECT DISTINCT DEPTNO FROM EMP
       > 10
         20
         30
  
 TOP clause:
 -----------
   > To select top N rows of table
   > SELECT TOP <n> colnames/* FROM tablename [WHERE cond] [ORDER BY colnames]

   > Examples
     > Display first 5 rows from EMP table
       > SELECT TOP 5 EMPNO,ENAME,SAL FROM EMP

     > Display TOP 5 highest paid Employees based on salary
       > SELECT TOP 5 EMPNO,ENAME,SAL FROM EMP ORDER BY SAL DESC 
     
     > Display TOP 5 empleyees based on experience
       > SELECT TOP 5 EMPNO,ENAME,SAL,HIREDATE FROM EMP ORDER BY HIREDATE ASC //here ASC means who joined first will come first
     
     > Display TOP 3 Maximum salaries from empleyee list
       > SELECT DISTINCT TOP 3 SAL FROM EMP ORDER BY SAL DESC // DISTINCt is applied to elemenate duplicates

 DML Commands: ( Data Manipulation language)
 ---------------------------------------

   > Lke INSERT UPDATE DELETE MERGE
   > DML commands acts on table data
   > All these operations are auto committed i.e., 'automatically saved'
     > To STOP autp commit execute the following command
       > SET IMPLICIT_TRANSACTIONS ON
     > To Save operations execute COMMIT command //as auto save is off from the above command
     > To cancel operations execute ROLLBACK command
   
   > INSERT
     > To create new row // refer 118 line INSERT at the start 

   > UPDATE command
     > command used to modify data, can update all rows are specific row, 
       can update sigle column or multiple columns

     > Syntax 
        > UPDATE tablename SET colname = value, colname = value,.... WHERE condition

     > Examples:
       > Update all empleyee commision with 500
         > UPDATE EMP SET COMM = 500
       > Update empleyee commision with 500 whose commision is null
         > UPDATE EMP SET COMM = 500 WHERE COMM IS NULL
       > Update commision with Null whose commision is not equal to null
         > UPDATE EMP SET COMM = NULL WHERE COMM IS NOT NULL // null assignment is = and null comparision is 'IS'
       > Update salary with 2000 and commision with 500 whose id = 7369
         > UPDATE EMP SET SAL = 2000, COMM = 500 WHERE EMPNO = 7369
       > Update increment salary by 20% and commision by 10% who working as SALESMAN and joined in 1981 
         > UPDATE EMP SET SAL = SAL + (SAL * 0.2) COMM = COMM + (COMM * 0.1) WHERE JOB = 'SALESMAN' AND HIREDATE LIKE '1981%'

170523

 Examples:
  > PRODUCTS
    prodid pname price category BRAND
   >Increase the price of all samsung, realme, oneplus brand mobile phones by 10%
     > UPDATE PRODUCTS SET PRICE = PRICE + (PIRCE*0.1) WHERE BRAND IN ('SAMSUNG','REALME','ONEPLUS') AND CATEGORY = 'MOBILES'

  DELETE command
  ==============
   > Command used to delete row/rows based on condition
   > We can delete all rows or specific row
   > Syntax 
      > DELETE FROM <tablename> [WHERE condition] // if Where condition is not given all rows are deleted
   > Examples 
     > Delete all rows from EMP table // dont forget to execute 'SET IMPLICIT_TRANSACTIONS ON' and save manually 'COMMIT'
       > DELETE FROM EMP
     > Delete empleyees joined in 1980
       > DELETE FROM EMP WHERE HIREDATE LIKE '1980%'

  DDL commands: ( DATA DEFINITION LANGUAGE)
  =============
   > CREATE ALTER DROP TRUNCATE are called DDL commands
   > All DDL commands acts on table structure (columns, datatype and size)

   ALTER command:
   --------------
    > command used to modify table structure
    > using ALTER command we can 
      > Add columns
      > Drop columns
      > modify columns
        > changing datatype
        > changing size
     Adding columns:
     > syntax 
        > ALTER TABLE <tablename> ADD COLNAME DATATYPE(size), COLNAME DATATYPE(size),...
     > Examples:
       > Add column gender to emp table
         > ALTER TABLE EMP ADD GENDER CHAR(1) // by default new column is filledw with 'NULL'
         > To insert data into new column use update command
          > UPDATE EMP SET GENDER = 'M' WHERE EMPNO = 7499
  
     Dropping columns:
       > ALTER TABLE <tablename> DROP COLUMN COL1, COL2
       > Examples:
       > Drop column gender from EMP table
       > ALTER TABLE EMP DROP COLUMN GENDER
  
     Modify columns:
       > Syntax:
         > ALTER TABLE <tablename> ALTER COLUMN <colname> TYPE(SIZE)
       > Examples:
         > Increase size of ENAME to 20
           > ALTER TABLE EMP ALTER COUMN ENAME VARCHAR(20) // decrease also possible upto the exisiting data size
         > Change data type of EMPNO to INT
           > AKTER TABLE EMP ALTER COLUMN EMPNO INT // ALTER TABLE EMP ALTER COLUMN EMPNO TINYINT gives ERROR as exiting values are bigger for tinyint

   DROP Command:
   -------------
   > Command drops table from DB
   > Drops table structure along with data
   > Syntax:
      > DROP TABLE <tablename>
   > Examples:
     > DROP TABLE EMP
  
   TRUNCATE command:
   ----------------
    > Deletes all data from the table but keeps structure
    > Will empty the table 
    > Releases moemory allocated for table
    > When truncate is executed sql server goes 
      to memory and releases all the pages allocated for the table
      and when pages are released then date stored in the page also deleted
    > Syntax: TRUNCATE TABLE <table name>
    > Examples: TRUNCATE TABLE EMP

   Question: Differetiate between DROP DELETE TRUNCATE
     > DROP deletes table structure with data
     > DELETE/TRUNCATE deletes only data but not structure
     > DELETE VS TRUNCATE
       > DELETE comes under DML , TRUNCATE comes under DDL
       > DELETE can delete specific rows, TRUNCATE cannot delete specific rows
       > Where condition can be used with DELETE, Where condition cannot be used with TRUNCATE
       > DELETE command deletes row by row, TRUNCATE deletes all rows at a time but cannot single row
       > DELETE is slower, TRUNCATE is faster
       > DELETE will not release memory, TRUNCATE will release memory immediately
       > DELETE will not reset identity, TRUNCATE will reset identity
  
   SP_REMANE: ( SP is STORED PROCEDURE)
   -------------------------------------
     > Used to change the tablename and column name
     > Syntax:
       > SP_REMANE '<oldname>', '<newname>'
     > Examples:
        > Rename EMP table to EMPLOYEES table
         > SP_REMANE 'EMP','EMPLOYEES'
        > Rename column commision to bonus
         > SP_REMANE 'EMPLOYEES.COMM','BONUS' // <tablename.columnname> to change column name in the table

180523

 > Built-in Functions in SQL Server:
   =================================
    > A function accepts some inputs performs some calculations and returns one result

    > Types of functions:
      -------------------
       > DATE STRING NUMERIC CONVERSION SPECIAL ANALYTICAL AGGREGATE 

       > DATE Functions:
         > GETDATE():
           > Returns current date, time and milliseconds
             > SELECT GETDATE() returns 2023-05-18 11:26:41.820 

         > DATEPART():
           > Function used to extract part of the date
             > DATEPART(INTERVAL,DATE)
             > Examples:
               > SELECT DATEPART(YY,GETDATE()) returns 2023
               > SELECT DATEPART(MM,GETDATE()) returns 05
               > SELECT DATEPART(DD,GETDATE()) returns 18
               > SELECT DATEPART(DW,GETDATE()) returns 5 // 1 for Sunday .... 7 for Saturday ....
               > SELECT DATEPART(HH,GETDATE()) returns Hours
               > SELECT DATEPART(MI,GETDATE()) returns Minutes
               > SELECT DATEPART(SS,GETDATE()) returns Seconds
               > SELECT DATEPART(Q,GETDATE()) returns Quarter // like 1 Jan- Mar, 2 Apr- Jun, 3 Jul- Sept, 4 Oct- dec
               > SELECT DATEPART(DAYOFYEAR,GETDATE()) returns day in a year
               > SELECT DATEPART(DY,GETDATE()) returns day in a year

               > Display Employees joined in 1980, 1983, 1985
                 >SELECT * FROM EMP WHERE DATEPART(YY,HIREDATE) IN (1980,1983,1985)

               > Display Employees joined in leap year
                 > SELECT * FROM EMP WHERE DATEPART(YY,HIREDATE) % 4 = 0
               
               > Display Employees joined in January, April, December months
                 > SELECT * FROM EMP WHERE DATEPART(MM,HIREDATE) IN (1,4,12)
               
               > Display Employees joined on Sunday
                 > SELECT * FROM EMP WHERE DATEPART(DW,HIREDATE) IN (1)

               > Display Employees joined in 2nd quarter of 1981
                 > SELECT * FROM EMP WHERE DATEPART(YY,HIREDATE) = 1981 AND DATEPART(Q,HIREDATE) = 2
               
         > DATENAME();
           > Used to extract part of the date

           >                  MM                    DW
           > DATEPART          5                     5
           > DATENAME          MAY                   THURSDAY

          > Examples:
             > Display Employee with name and joinday
               > SELECT ENAME, DATENAME(DW,HIREDATE) AS DAY FROM EMP

             > Display day of India's Independence Day
               > SELECT DATENAME(DW,'1947-08-15')
           
         > FORMAT():
           > Used to display dates in different formats
           > FORMAT(DATE,'<format>')
           
           > Examples:
             > SELECT FORMAT(GETDATE(),'dd-MM-yyyy')
             > SELECT FORMAT(GETDATE(),'MM/dd/yyyy')

             > Display the name hiredate, hiredate in MM/DD,YYYY format
               > SELECT ENAME,FORMAT(HIREDATE,'MM/dd/yyyy')AS HIREDATE FROM EMP
             
             > SELECT FORMAT(GETDATE(),'DD-MM-yyyy hh:mm:ss') // can get both date and time with formats

             > Display the list of empleyees joined today
               > SELECT * FROM EMP WHERE HIREDATE = FORMAT(GETDATE(),'yyyy-MM-dd')
         
         > DATEDIFF():
           > Function used to find difference between two dates
           > DATEDIFF(INTERVAL,START DATE, END DATE)

           > Examples:
             > SELECT DATEDIFF(YY,'2022-05-18',GETDATE()) returns 1
             > SELECT DATEDIFF(MM,'2022-05-18',GETDATE()) returns 12
             > SELECT DATEDIFF(DD,'2022-05-18',GETDATE()) returns 365
            
             > Display name amd experience in years
               > SELECT ENAME,DATEDIFF(YY,HIREDATE,GETDATE()) AS EXPERIENCE FROM EMP

             > Display name amd experience in years,months
               > SELECT ENAME,DATEDIFF(MM,HIREDATE,GETDATE())/12 AS YEARS, DATEDIFF(MM,HIREDATE,GETDATE())%12 AS MONTHS FROM EMP

190523

         > DATEADD():
           > Used to add/subtract days, months,years to/from a date.
           > Syntax:
             > DATEADD(INTERVAL, INT, DATE)
           > Examples:
             > Add 10 days to GETDATE()
               > SELECT DATEADD(DD, 10, GERDATE()) gives 2023-05-29 
             > Add 2 months to GETDATE()
               > SELECT DATEADD(MM,2,,GETDATE()) gives 2023-07-19
             > subtract 1 year from GETDATE()
               > SELECT DATEADD(YY,-1,GETDATE()) gives 2022-05-19

             > Scenario:
               > GOLD_RATES
                 DATEID         RATE
                 2020-01-01      ?
                 2020-01-02      ?

                 2023-05-19      ?

               > Display today's gold rate
                 > SELECT * FROM GOLD_RATES WHERE DATEID = FORMAT(GETDATE(),'yyyy-MM-dd')

               > Display yesterday's gold rate
                 > SELECT * FROM GOLD_RATES WHERE DATEID = FORMAT(DATEADD(DD,-1,GETDATE()),'yyyy-MM-dd')

               > Display last month same day gold rate
                 > SELECT * FROM GOLD_RATES WHERE DATEID = FORMAT(DATEADD(MM,-1,GETDATE()),'yyyy-MM-dd')

               > Display last year same day gold rate
                 > SELECT * FROM GOLD_RATES WHERE DATEID = FORMAT(DATEADD(YY,-1,GETDATE()),'yyyy-MM-dd')

               > Display last one month gold rates
                 > SELECT * FROM GOLD_RATES WHERE DATEID BETWEEN DATEADD(MM,-1,GETDATE()) AND GETDATE()

 ----------------------------------------------------------------------------------------------------------------------
 NOTE:
   > SQL Server date stats from 1900-01-01 , 
     > Examples:
       > FIrst date in SQL calender
         > SELECT DATEADD(DD,0,0) gives 1900-01-01
 ----------------------------------------------------------------------------------------------------------------------

          > EOMONTH():
            > Returns last day of the month
            > Syntax:
              > EOMONTH(DATE,INT)
            > Examples:
              > SELECT EOMONTH(GETDATE(),0) gives 2023-05-31
              > SELECT EOMONTH(GETDATE(),1) gives 2023-06-30
              > SELECT EOMONTH(GETDATE(),-1) gives 2023-04-30
              > Display next month first day
              > Display current month first day
              > Display next year first day
              > Display current year first day

       > STRING FUNCTIONS:
        -------------------

         > UPPER():
           > Used to convert string to uppercase
           > Syntax:
             > UPPER(string)
           > Examples:
             > SELECT UPPER('hello') gives HELLO
         
         > LOWER():
           > Used to convert string to lowercase
           > Syntax:
             > LOWER(string)
           > Examples:
             > SELECT LOWER('HELLO') gives hello

             > Display EMPNO ENAME SAL, names in lowercase
               > SELECT EMPNO,LOWER(ENAME) AS ENAME, SAL FROM EMP // SELECT will only display data not modify actual table data

             > Change names to lowercase in table
               > UPDATE EMP SET ENAME = LOWER(ENAME) // UPDATE changes data in table itself
               
         > LEN():
           > Returns string length i.e., no of characters
           > Syntax:
             > LEN(string)
           > Examples:
             > SELECT LEN('hello world') gives 11 characters

             > Display Employee name and length of the name
               > SELECT ENAME, LEN(ENAME) AS LENGTH FROM EMP 
             > Display Employee names containing 4 characters
               > SELECT * FROM EMP WHERE ENAME LIKE '____' // not idel for all scenarios , like 30 characters
               > SELECT * FROM EMP WHERE LEN(ENAME)=4 

         > LEFT()
           > Returns characters starting from left
           > Syntax
             > LEFT(string,LEN)
           > Examples
             > SELECT LEFT('hello world',5) returns 5 characters starting from left side

             > Display empleyee names starting with 's'
               > SELECT * FROM EMP WHERE LEFT(ENAME,1)='s'
         
         > RIGHT()
            > Returns characters starting from right side
            > Syntax
              > RIGHT(string,LEN)
            > Examples
              > SELECT RIGHT('hello world',7) gives o world

              > Display Employee names that ends with 's'
                 > SELECT * FROM EMP WHERE RIGHT(ENAME,1)='s'
              > Display Employee names that start and end with same characters
                 > SELECT * FROM EMP WHERE LEFT(ENAME,1) = RIGHT(ENAME,1)
         
         > SUBSTRING():
           > Returns characters starting from specific position
           > Syntax 
             > SUBSTRING(string,start,len)
           > Examples 
             > SELECT SUBSTRING('hello world',7,4) gives worl
             > SELECT SUBSTRING('hello world',10,3) gives ld
             
             > Scenario:
               > Generate emailids for employees
                 > EMPNO    ENAME     EMAILID
                   7369     Smith      smi736@tcs.com
                   7499     Allen      all749@tcs.com
               > SELECT EMPNO, ENAME, LEFT(ENAME,3) + LEFT(EMPNO,3) + '@tcs.com'AS EMAILID FROM EMP // displays only

               > Add EMAILID in DB
                > Step 1 : Add EMAILID column to EMP table
                   > ALTER TABLE EMP ADD EMAILID VARCHAR(30)
                > Step 2 : Update the column with emailids
                   > UPDATE EMP SET EMAILID = LEFT(ENAME,3) + LEFT(EMPNO,3) + '@tcs.com'

200523

 > CHARINDEX():
   ------------
    > Used to returns position of a character in a string
    > syntax
      > CHARINDEZ(CHAR,STRING,[START]) // START is optional
    > Examples:
      > SELECT CHARINDEX('O','HELLO WELCOME') returns 5 // if characteris retunrs postion, if not retunrs 0
      > SELECT CHARINDEX('X','HELLO WELCOME') returns 0

      > In 'HELLO WELCOME" find position of O starting from 6
        > SELECT CHARINDEX('O','HELLO WELCOME',6) returns 11

      > Assignment
        > CUST
          CID    NAME
          10     SACHIN TENDULKAR
          11     ROHIT SHARMA

          > Display CID FNAME      LNAME
                    10  SACHIN     TENDULAKAR  
            using LEFT RIGHT SUBSTRING CHARINDEX

  > REPLICATE():
    ------------
    > Used to repeat character for  given numboer of times
    > Syntax:
      > REPLICATE(CHAR,LEN)
    > Examples:
      > SELECT REPLICATE('*',5) gives ***** // 5 stars

      > Display salaries as stars
        > SELECT ENAME,REPLICATE('*',LEN(SAL)) AS SAL FROM EMP

      > Scenario
        > ACCOUNTS 
          ACCNO               ACTYPE    BAL
          1234567892          S         10000
         > Display 'your a/c no XXXX8962 debited _____' // XXXX in place of number 
            > REPLICATE('X',4) + RIGHT(ACCNO,4)

  > REPLACE():
   -----------
   > Used to replacee one string with another string
   > Syntax:
     > REPLACE(str1,str2,str3) returns in str1, str2 replaced with str3
   > Examples:
     > Replace 'ell' with 'abc' in 'hello'
       > SELECT REPLACE('hello','ell','abc') returns 'habco'
     > Replace 'l' with 'abc' in 'hello'
       > SELECT REPLACE('hello','l','abc') returns 'heabcabco'
     > Replace 'elo' with 'abc' in 'hello'
       > SELECT REPLACE('hello','elo','abc') returns 'hello' // 'elo' is not there in string so not replaced
     > Removing unwanted characters, like '@' here 
       > SELECT REPLACE('@@he@@ll@@o@@','@','') gives 'hello' // '' refers null
     > Remove only last ',' in " a,b,c,d,c,e, "
       > 

  > STUFF();
    -------
    > Also similar to replace i.e., used to replace one string with another string
    > Based on start and length
    > Syntax:
       > STUFF(string1,start,length,string2)
    > Examples:
       > Replace 3 characters with 'ABC' starting from 10th character in 'HELLO WELCOME'
         > SELECT STUFF('HELLO WELCOME',10,3,'ABC') gives 'HELLO WELABC'
       > SELECT STUFF('A,B,C,D,',8,1,") gives A,B,C,D

  > TRANSLATE():
    ------------
    > Used to translate one character to another character.
    > Translation cannot be null like SELECT TRANSLATE('HELLO','ELO','') gives ERROR
    > Syntax:
      > TRANSLATE(str1,str2,str3)
    > Examples:
      > SELECT TRANSLATE('HELLO','ELO','ABC') gives 'HABBC' // here E to A, L to B, O to C

    > Note: TRANSLATE function can be used to encrypt data i.e., changing plain text to cipher text
      > Examples:
        > Encrypt Salaries of EMP table
          > SELECT ENAME,TRANSLATE(SAL,'0123456789.','$bT*k@G^#%&') AS SAL FROM EMP
        
        > Remove all the special characters from '@#HE%$LL&^O*@'
          > SELECT  REPLACE (TRANSLATE('@#HE%$LL&^O*@','@#%$&^*','*******'),'*','')  // first translate all the special characters to '*'s, then make it as input to replace
            > Stepl: **HE**LL**O*
            > Step2: HELLO

 > Numeric finctions:
   ===================
   > ABS(): retunrs absolute value
     > Syntax: ABS(NUMBER)
     > Examples:
       > SELECT ABS(10) returns 10
       > SELECT ABS(-10) returns 10 // Always returns positive value

   > POWER():
     > Calculates POWER
     > Syntax: POWER(NUM1,num2)
     > Examples:
       > SELECT POWER(3,2) returns 9

   > SQRT():
     > Returns square root
     > Syntax: SQRT(NUM1)
     > Examples: SELECT SQRT(16) returns 4

   > SQUARE():
     > Returns square of a number
     > Syntax: SQUARE(NUM1)
     > Examples: SELECT SQUARE(5) returns 25
   
   > SIGN():
     > To check whether given number is positive or negative
     > Syntax: SIGN(NUM1)
     > Examples:
        > SELECT SIGN(10) returns 1
        > SELECT SIGN(-10) returns -1
        > SELECT SIGN(0) returns 0

   > Rounding number:
    ------------------
    > ROUND CEILING FLOOR are 3 functions available for Rounding numbers
    
220523

    > ROUND():
     > Rounds number to integer or to decimal places 
     > Round function acts according to average 
     > Syntax: Round(number, decimal places)
     > Examples:
       > SELECT ROUND(38.4567,0) gives 38 //here 0 means this number is rounded to integer
         > If number < Avg rounded to lowest
         > If number >= Avg rounded to highest
       > SELECT ROUND(38.4567,2) gives 38.46
       > SELECT ROUND(38.4547,2) gives 38.45
       > SELECT ROUND(326,-2) gives 400 // -2 means rounding to 100s
         > 300----------350----------400
       > SELECT ROUND(326,-1) gives 360 // -1 means rounding to 10s
         > 350-----------355---------360
       > SELECT ROUND(356,-3) gives 0 // -3 means rounding to 1000s
         > 0-------------500---------1000

       > SELECT ROUND(4567,-1),ROUND(4567,-2),ROUND(4567,-3)
         >            4570           4600            5000

    > CEILING():
      > Rounds number always to highest
      > Example:
        > SELECT FLOOR(38.9) gives 38
    
  > Conversion funcitons:
    ---------------------
    > Used to convert one datatype to another datatype
    > There are two fucntions available CAST CONVERT
    
    > CAST():
      > Syntax
        > CAST(SOURCE-EXPR AS TARGETTYPE)
      > Examples:
        > SELECT CAST(10.5 AS INT) gives 10 // 10.5 is converted to integer
        > SELECT CAST(10 AS DECIMAL) gives 10

        > Display employees 'Smith earns 800', 'ALLEN earns 1600' from EMP Table
          > SELECT ENAME + 'ears' + SAL FROM EMP gives ERROR // All must be character type for concatination
          > SELECT ENAME + 'ears' + CAST(SAL AS VARCHAR) FROM EMP

        > Display 'Smith joined on 1980-12-17 as clerk'
          > SELECT ENAME + ' joined on' + CAST(HIREDATE AS VARCHAR) + 'as' + job FROM EMP
    
    > CONVERT():
      > Syntax:
        > CONVERT(target-type,source-expr)
      > Example:
        > SELECT CONVERT(INT,10.5) gives 10
    
     Note: Using convert we can display dates/money in different formats which is not possible in cast 
      > Date styles:
        > CONVERT(VARCHAR,DATE,STYLE-NUMBER) 
        > Examples:
          > SELECT CONVERT(VARCHAR,GETDATE(),101) gives 05/22/2023 // 101 is predefines style number
          > SELECT CONVERT(VARCHAR,GETDATE(),102) gives 2023.05.22 
            > like this predefined Style-number ranges from 100 to 115 
            > Compared to this FORMAT is more felxible
        
          > Display ENAME, HIREDATE as dd-MM-yyyy format
            > SELECT ENAME,CONVERT(VARCHAR,HIREDATE,105) AS HIREDATE FROM EMP
          > DATEADD with CONVERT
            > SELECT DATEADD(DD,5,CONVERT(DATE,'10/05/2023',103)) gives 2023-05-15 // here with CONVERT date is treated as dd/MM/yyy
            > SELECT DATEADD(DD,5,'10-05-2023') gives 2023-10-10 00:00:00.000  // here without CONVERT date is treated as MM/dd/yyy
      
      > Money styles:
        > Syntax:
          > CONVERT(CARCHAR,NONEY,STYLE-NUMBER)
          > SELECT ENAME,CONVERT(VARCHAR,SAL,0) AS SAL FROM EMP
         > Exmaples:  
           > SELECT ENAME,CONVERT(VARCHAR,SAL,0) AS SAL FROM EMP
           > SELECT ENAME,CONVERT(VARCHAR,SAL,1) AS SAL FROM EMP
           > SELECT ENAME,CONVERT(VARCHAR,SAL,2) AS SAL FROM EMP
           > SELECT CONVERT(VARCHAR,CAST(5000 AS MONEY),1) gives 5,000.00
      
  > SPECIAL Functions:
    ------------------
    > ISNULL():
      > Function used to convert null values
      > This is used to skip NULL // as  NULL +-* NULL is NULL
      > Syntax:
        > ISNULL(arg1,arg2)
      > Example:
        > SELECT ISNULL(100,200) gives 100 // as first arg is not equal to null
        > SELECT ISNULL(NULL,200) gives 00 // as first arg is equal to null gives arg2

        > Display Employee salary with commision
          > SELECT ENAME,SAL,COMM,SAL+COMM AS TOTSAL FROM EMP // Emplouyees with NULL commission were gives NULL TOTALSAL
          > SELECT ENAME,SAL,COMM,SAL+ISNULL(COMM,0) AS TOTSAL FROM EMP gives SAL + COMM // NULL is taken as 0

230523

        > Display ENAME SAL COMM TOTSAL, if COMM is NULL display 'No Commission'
          > SELECT ENAME,SAL,ISNULL(CAST(COMM AS VARCHAR),'NO COMM') AS COMM FROM EMP // ISNULL(arg1,arg2) arg2 must be same type as arg1 type
        
  > Analytical functions or window functions:
    =========================================
    > Mainly useed for data analysis
    > Mainly there two functions RANK, DENSE_RANK
      > These both functions are used to find ranks
      > Ranking is always based on columns like SAL,HIREDATE etc
      > For rank functions data must be sorted 
      > Syntax
        > RANK() OVER ( ORDER BY COLNAME ASC/DESC)
        > DENSE_RANK() OVER ( ORDER BY COLNAME ASC/DESC)
      > Examples:
        > RANK() OVER(ORDER BY SAL DESC)
        > RANK() OVER(ORDER BY SAL ASC)
        > Find ranks of the empleyees based on salary and highest paid should get first rank
          > SELECT ENAME,SAL,RANK() OVER(ORDER BY SAL DESC) AS RANK FROM EMP
          > SELECT ENAME,SAL,DENSE_RANK() OVER(ORDER BY SAL DESC) AS RANK FROM EMP
      > Difference between RANK and DENSE_RANK
        > RANK function generate gaps but DENSE_RANK will not generate gaps
        > RANK function ranks may not be in sequence but in DENSE_RANK rank is always in sequence
        > Example
          > SAL       RANK       DENSE_RANK
            5000      1          1
            4000      2          2
            3000      3          3
            3000      3          3
            3000      3          3
            2000      6          4
            2000      6          4
            1000      8          5
        > Display ranks of Emplouyees based on hiredate
          > SELECT ENAME,HIREDATE,DENSE_RANK() OVER (ORDER BY HIREDATE ASC) AS RANK FROM EMP
        > Display ranks of Emplouyees based on salary and if have same salary then rank bansed on hiredate
          > SELECT ENAME,HIREDATE,SAL,DENSE_RANK() OVER (ORDER BY SAL DESC,HIREDATE ASC) AS RANK FROM EMP
      
    > PARTITION BY clause:
      --------------------
      > Used to find ranks within group
        > Display ranks within a department
          > Divide table department wise
          > Apply DENSE_RANK on each department instead of ranking whole table
          > SELECT ENAME,HIREDATE,SAL,DEPT, DENSE_RANK() OVER(PARTITION BY DEPT ORDER BY SAL DESC) AS RANK FROM EMP
    
    > ROW_NUMBER():
      -------------
      > Returns record number
      > Also based on some column
      > Syntax:
        > ROW_NUMBER() OVER(ORDER BY COLNAME ASC/DESC,---)
      > Examples:
        > SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER(ORDER BY SAL DESC) AS RNO FROM EMP
        > SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER(ORDER BY EMPNO ASC) AS RNO FROM EMP
    
    > LAG() & LEAD():
      ---------------
      > LAG(COLNAME,INT) OVER (ORDER BY COLNAME) returns previous value
      > LEAD(COLNAME,INT) OVER (ORDER BY COLNAME) returns next value
      > SELECT EMPNO, ENAME, HIREDATE, SAL, LAG(SAL,1) OVER( ORDER BY HIREDATE ASC) AS PREV_SAL FROM EMP 
      > After how many days employee hired in EMP table
        > SELECT EMPNO, ENAME, HIREDATE, LAG( HIREDATE,1) OVER ( ORDER BY HIREDATE ASC ) AS PREV_HIREDATE FROM EMP
        > SELECT EMPNO, ENAME, HIREDATE, LAG( HIREDATE,1) OVER ( ORDER BY HIREDATE ASC ) AS PREV_HIREDATE, DATEDIFF(DD,LAG(HIREDATE,1) OVER (ORDER BY HIREDATE ASC),HIREDATE) AS DAYS FROM EMP
      > Days between the two employees hiredate in EMP Table
        > SELECT EMPNO, ENAME, HIREDATE, LAG( HIREDATE,1) OVER ( ORDER BY HIREDATE ASC ) AS PREV_HIREDATE, DATEDIFF(DD,LAG(HIREDATE,1) OVER (ORDER BY HIREDATE ASC), HIREDATE) AS GAP FROM EMP
        
240523

 > Aggregate functions:
   --------------------
   > Takes group of rows, returns one value
   > MAX():
     > Returns maximum value
     > Syntax:
       > MAX(arg)
         > Examples:
           > SELECT MAX(SAL) FROM EMP  gives 5000// takes all the values and returns the maximum value
           > SELECT MAX(HIREDATE) FROM EMP gives 1983-01-12
           > SELECT MAX(ENAME) FROM EMP gives WARD
   > MIN()
     > Syntax:
       > MIN(arg)
     > Examples:
       > SELECT MIN(SAL) FROM EMP gives 800// takes all the values and returns the minimum value
   > SUM()
     > Syntax:
       > SUM(arg)
     > Examples:
       > SELECT SUM(SAL) FROM EMP gives 29025// takes all the values and adds them
       > Round total salaries to 100s
         > SELECT ROUND(SUM(SAL),-2) FROM EMP gives 29000.00
       > After rounding to 100s display total salary with 1000 seperator
         > SELECT CONVERT(VARCHAR,ROUND(SUM(SAL),-2),1) FROM EMP gives 29,000.00
       > Display total salary paid to managers
         > SELECT SUM(SAL) FROM EMP WHERE JOB = 'MANAGER' gives 8275
       > Display totol salary including commission
         > SELECT SUM(SAL + ISNULL(COMM,0)) AS TOTSAL FROM EMP gives 31225\
   > AVG()
     > Syntax
       > AVG(arg)
       > Examples:
         > Display average salary of EMP table
           > SELECT AVG(SAL) AS AVGSAL FROM EMP gives 2073.2142
         > Round average salary of EMP table to lowest
           > SELECT FLOOR(AVG(SAL)) AS LOWEST FROM EMP gives 2073
   > NOTE:
     > SUM, AVG, connot be applied on char, date columns, can be applied only on numberic columns
       > SELECT SUM(HIREDATE) FROM EMP gives error
   > COUNT()
     > Returns number of values present in a column
     > Syntax
       > COUNT(arg)
     > Examples
       > Display number of values in EMPNO of EMP Table
         > SELECT COUNT(EMPNO) FROM EMP //  COUNT function ignores NULLS
       > Display numner of rows from EMP Table
         > SELECT COUNT(*) FROM EMP  // here nulls are counted
       > Display number of employees joiend in 1981 year from EMP Table
         > SELECT COUNT(*) FROM EMP WHERE DATEPART(YY,HIREDATE) = 1981 gives 10 
       > Display employees joind on Sunday from EMP Table 
         > SELECT COUNT(*) FROM EMP WHERE DATENAME(DW,HIREDATE) = 'SUNDAY' gives 1
       > Display number of employees joind in 2nd querter of 1981 from EMP Table
         > SELECT COUNT(*) FROM EMP WHERE DATEPART(YY,HIREDATE) = 1981 AND DATEPART(Q,HIREDATE) = 2 gives 3
   > Note: Aggregate function are not allowed in WHERE clause and are allowed in  SELECT, HAVING clauses
  
  > CASE statement:
    ---------------
    > Similar to switch case
    > Used to implement if-then-else
    > Used to return values based on condition
    > Case statements are of two Types
      > Simple case , Searched case
    > SIMPLE case
      > When conditions based on '=' operator
      > Syntax
        > CASE COLNAME WHEN value1 THEN RETURN expr1 WHEN value2 THEN RETURN expr2 .... [ELSE RETURN expr] END
      > Examples:
        > Display ENAME and DNAME like 
          IF DEPTNO = 10 DISPLAY ACCOUNTS   
                      20         RESEARCH
                      30         SALES
          > SELECT ENAME,DEPT, CASE DEPT WHEN 10 THEN 'ACCOUNTS' WHEN 20 THEN 'RESEARCH' WHEN 30 THEN 'SALES' ELSE 'UNKNOWN' END AS DNAME FROM EMP
        > Update Employee salaries with Increment as follows
          if job = CLERK incr sal by 10%
                   SALESMAN          15%
                   MANAGER           20%
                   OTHERS            5%
          > UPDATE EMP SET SAL = CASE JOB WHEN 'CLERK' THEN SAL + (SAL*0.1) WHEN 'SALEMAN' THEN SAL + (SAL*0.15) WHEN 'MANAGER' THEN SAL + (SAL*0.2) ELSE SAL + (SAL*0.05) END 

250523

    > Searched case
      > When conditions not based on '=' operator
      > Syntax
        > CASE WHEN cond1 THEN RETURN expr1 WHEN cond2 THEN RETURN expr2 ..... [ELSE RETURN expr] END
      > Examples:
        > Display ENAME SAL SALRANGE
          IF SAL > 3000 display HISAL
             SAL < 3000 display LOSAL
             SAL = 3000 display AVGSAL
          > SELECT ENAME, SAL, CASE WHEN SAL > 3000 THEN 'HISAL' WHEN SAL < 3000 THEN 'LOSAL' ELSE 'AVGSAL' END AS SALRANGE FROM EMP 
        > Display SNO TOTAL AVG RESULT from 
          STUDENT 
          SNO   SNAME   S1  S2  S3
          1     A       80  90  70
          2     B       30  60  50
          > SELECT SNO, S1 + S2 + S3 AS TOTAL, (S1 + S2 + S3)/3 AS AVG, CASE WHEN S1 >= 35 AND S2 >= 35 AND S3 >= 35 THEN 'PASS' ELSE 'FAIL' END AS RESULT FROM STUDENT
          > CASE statement with in sum fucntion
            > SELECT SUM(CASE JOB WHEN 'CLERK' THEN SAL END) AS CLERK, SUM(CASE JOB WHEN 'MANAGER' THEN SAL END) AS MAMNAGR FROM EMP
          > Department wise total salary
            > Group by clause can be used 

      > GROUP BY clause:
        > Used to group rows based on one or more columsn to calculate min, max, sum, avg, count for each group
        > GROUP BY converts detailed data into summarized data which is useful for anlysis
        > To calculate total salary of job wise, department wise....
        > Syntax
          > SELECT columns FROM tabname [WHERE cond] GROUP BY colname [JAVING cong] [ORDER BY colname ASC/SESC]
          > Execution order
            > FROM WHERE GROUP BY HAVING SELECT ORDER BY 
        > Examples:
          > To calculate department wise total salary
            > first gorup records based on salary then calculate sum(sal) for each department
            > SELECT DEPT, SUM(SAL) AS TOTSAL FROM EMP GROUP BY DEPT
          > Display Job wise number of employees joined
            > SELECT JOB, COUNT(*) AS CNT FROM EMP GROUP BY JOB
          > Display Year wise number of employees joined
            > SELECT DATEPART(YY,HIREDATE) AS YEAR, COUNT(*) AS CNT FROM EMP GROUP BY DATEPART (YY,HIREDATE)
          > Display Day wise number of employees joined
            > SELECT DATEPART(DW,HIREDATE) AS DAY, COUNT(*) AS CNT FROM EMP GROUP BY DATEPART (DW,HIREDATE)
          > Display Salary range for employees in EMP table
            0-2000 2001-4000 >4000
            > SELECT CASE
             WHEN SAL BETWEEN 0 AND 2000 THEN '0-2000' 
             WHEN SAL BETWEEN 2001 AND 4000 THEN '0-4000' 
             WHEN SAL>4000 THEN '> 4000'
             END AS SALRANGE, COUNT(*) AS CNT
             FROM EMP 
             GROUP BY CASE 
             WHEN SAL BETWEEN 0 AND 2000 THEN '0-2000' 
             WHEN SAL BETWEEN 2001 AND 4000 THEN '0-4000' 
             WHEN SAL>4000 THEN '> 4000'  
             END
                 
260523

          > Display number of joined in each month of year 1981
            > SELECT DATENAME(MM,HIREDATE) WHERE DATEPART(YY,HIREDATE) = 1981 GROUP BY DATENAME(MM,HIREDATE)
          > Display employees having more than 3 employees in EMP table
            > SELECT DEPT, COUNT(*) AS CNT FROM EMP WHERE COUNT(*) > 3 GROUP BY DEPT gives error
              > Above querry returns error as sql server cannot calculate dept wise count before group by and it can calculate only after group by, so apply the condition COUNT(*) > 3 after group by using HAVING clause
              > SELECT DEPT,COUNT(*) AS CNT FROM EMP GROUP BY DEPT HAVING COUNT(*) > 3
    
      > WHERE VS HAVING :
        > WHERE                                        HAVING
          > Selects specific rows                      > Select specific group
          > conditions applied before group by         > conditions applied after group by
          > use WHERE clause if cond doesn't contain   > use HAVING clause if cond contains
            aggregate funtion                            aggregate function
      > Display number of employees for each job where job = CLERK,MANAGER and NO. of employees > 3
        > SELECT JOB,COUNT(*) AS CNT FROM EMP WHERE JOB IN ('CLERK','MANAGER') GROUP BY JOB HAVING COUNT(*) > 3
        > PERSONS
          AADHARNO   NAME   AGE   GENDER  ADDR  CITY  STATE
          > Display southern states having more than 5 cr population
          > SELECT STATE,COUNT(*) FROM PERSONS WHERE STATE IN ('AP,TS,KA,KL,TN') GROUP BY STATE HAVING COUNT(*) > 5000000

      > Goruping based on Multiple columns
        ----------------------------------
        > Display Dept wise and with in dept job wise total salary
          > SELECT DEPT,JOB,SUM(SAL) AS TOTSAL FROM EMP GROUP BY DEPT,JOB ORDER BY DEPT ASC
        > Questions:
          >  PERSONS
          AADHARNO   NAME   AGE   GENDER  ADDR  CITY  STATE
           > Display state wise population
           > Display gender wise population
           > Display age group wise population
           > Display state wise and with in state gender wise population
          
          > SALES
            DATEID     PRODID  CUSTID  QTY  AMOUNT
            2020-01-01  100    10      1    2000
            

            2023-05-26  127    11      1     3000
            > Display year wise total amount
            > Display year wise with in year quarter wise total amount
            > Display quarter wise total amount in the year 2022
              > QRT AMT PRE_QRT %INCR
                1   200  NULL
                2   150  200
                3   250  150
      
      > ROLLUP & CUBE:
        --------------
        > Both functions are used to display subtotals and grand total
        > Syntax:
          > GROUP BY ROLLUP(col1,col2,...)
          > GROUP BY CUBE(col1,col2,...)
        > ROllUP :
          > Displays subtotals for each group and also displays grand total
          > Examples:
            > SELECT DEPT,JOB,SUM(SAL) AS TOTSAL FROM EMP GROUP BY ROLLUP(DEPT,JOB) ORDER BY DEPT ASC
        > CUBE:
          > Displays subtotals for each group by column ( deptno,job)
          > Example:
            > SELECT DEPT,JOB,SUM(SAL) AS TOTSAL FROM EMP GROUP BY CUBE(DEPT,JOB) ORDER BY DEPT ASC
        
        > GROUPING_ID():
          -----------
          > Function accepts GROUP BY columns and returns subtortal belongs to which group by column
          > Example:
            > GROUPING_ID(DEPT,JOB) returns 1 
              > 1 means subtotal belongs to 1st GROUP BY column
              > 2 means subtotal belongs to 2nf GROUP BY column
              > 3 means grand total

270523

            > SELECT DEPT,JOB,SUM(SAL) AS TOTSAL, CASE GROUPING_ID(DEPT,JOB) WHEN 1 THEN 'Dept Subtotal' WHEN 2 THEN 'Job Subtotal' WHEN 3 THEN 'Grand Total' END AS SUBTOTRAL FROM EMP GROUP BY CUBE(DEPT,JOB) ORDER BY DEPT,JOB
 
 Note: Visit Kaggle.com for data sources examples
         > Datasets
           > Select desired Datasets
             > download .csv file // Comma Seperated Value .csv
        To load .csv file in your DB
        > Right click on your DB
          > Tasks
            > Import Data
            > SQL Server Import and Export Wizard
              > Data Source : Flat file // it's .csv file
              > File name: Select your downloaded .csv file
            > Specify where to copy data to
              > Destination : SQL Server
              > Authentication :
                > Username : SACHIN
                > Password : 123

        > To view all the exiting tables in DB
          > SELECT * FROM INFORMATION_SCHEMA.TABLES
        > To ramane table 
          > SP_RENAME 'existing table name', 'required change name'

  > Examples :  
    > Total samples by state wise from states table
      > SELECT STATE,SUM(CAST(TOTALSAMPLES AS BIGINT)) AS TOTSAL FROM COVID GROUP BY STATE
    > Statewise how many samples collected and also positives and negateives
      > SELECT STATE, SUM(CAST(TOTALSAMPLES AS BIGINT)) AS TOTAL, SUM(CAST(NEGATIVE AS BIGINT)) AS NEG, SUM(CAST(POSITIVE AS BIGINT)) AS POSIT FROM COVID GROUP BY STATE ORDER BY STATE ASC
    > Display only Talengana and Andhra Pradesh
      > SELECT STATE, SUM(CAST(TOTALSAMPLES AS BIGINT)) AS TOTAL, SUM(CAST(NEGATIVE AS BIGINT)) AS NEG, SUM(CAST(POSITIVE AS BIGINT)) AS POSIT FROM COVID WHERE STATE IN ('Andhra Pradesh','Telangana') GROUP BY STATE ORDER BY STATE ASC
    > Also group by date year
      > SELECT DATEPART(YY,CONVERT(DATE,DATE,105)) AS YEAR,SUM(CAST(TOTALSAMPLES AS BIGINT)) AS TOTAL, SUM(CAST(NEGATIVE AS BIGINT)) AS NEG, SUM(CAST(POSITIVE AS BIGINT)) AS POSIT FROM COVID WHERE STATE IN ('Andhra Pradesh','Telangana') GROUP BY STATE, DATEPART(YY,CONVERT(DATE,DATE,105)) ORDER BY STATE ASC 

 -----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

 > Integrity constraints:
   ======================
   > To maintain data quality
   > Used to prevent users from entering invalid data
   > Used to enforce rules like minimum balance must be 1000
   > SQL Server supports the following integrity constraints
     > NOT NULL
     > UNIQUE
     > PRIMARY KEY
     > CHECK 
     > FOREIGN KEY
     > DEFAULT
   > Above constraints are decalered in two ways
     > Column level
     > Table level
   > Column level:
     -------------
     > If constraints are decalred immediately after declaring column then it is called column level
     > Syntax:
       > CREATE TABLE <tablename> ( COLNAME DATETYPE(SIZE) CONSTRAINT,COLNAME DATETYPE(SIZE) CONSTRAINT.....)
     
     > NOT NULL:
       > NOT NULL doesn't accept NULL values
       > A column declared with NOT NULL is Mandatory column
       > Example
         > CREATE TABLE EMP11 (EMPID INT,ENAME VARCHAR(10) NOT NULL)
         > Testing
           > INSERT INTO EMP VALUE(100,NULL) gives error
           > INSERT INTO EMP VALUE(100,'SACHIN') gives 1 ROW AFFECTED
           
290523

           > INSER INTO EMP(EMPNO)VALUES(101) gives Error 
     
     > UNIQUE:
       > UNIQUE constraint doesn't accept duplicates
       > Examples:
         > Create table CUST
           > CREATE TABLE CUST(CID INT,CNAME VARCHAR(10) NOT NULL,EMAIL VARCHAR(30) UNIQUE) 
       > Testing:
         > INSERT INTO CUST VALUES( 100, 'A', 'abc@gmail.com')
         > INSERT INTO CUST VALUES( 101, 'B', 'abc@gmail.com') gives ERROR
         > INSERT INTO CUST VALUES( 102, 'C', 'null') gives 1 row effected
         > INSERT INTO CUST VALUES( 103, 'D', 'null') gives error // as nulls treated as same value everywhere
     
     > PRIMARY KEY:
       > Doen't accept duplicates and nulls
       > Combination of unique and not null
       > PRIMARY KEY is combination of UNIQUE and NOT NULL
       > In talbe one column must be there to identify records 
         and into that column duolicates and nulls are not allowed 
         and declare that column as primary key
       > Example
         > CREATE TABLE EMP22(EMPID INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL)
         > Testing
           > INSERT INTO EMP22 VALUES (100,'A')
           > INSERT INTO EMP22 VALUES (100,'B') gives Error // duplicates not allowed
           > INSERT INTO EMP22 VALUES (NULL,'C') gives Error // NULLS are not allowed
       > Note
         > Only one primary key is allowed per table
       > Example
         > CREATE TALBE CUSTS(CID INT PRIMARY KEY, NAME VARCHAR(10) NOT NULL,AADHARNO NUMERIC(12) UNIQUE NOT NULL) // as primary can be used only once use UNIQUE NOT NULL( no commas here ) which acts as primary to all others required
       
     > Difference between PRIMARY key and UNIQUE key
       > Primary doesn't allow nulls but unique allows one null
       > Only single can be declared with Primary key but multiple columns can be decalred with Unique 
     
     > Candidate key: // this is theoritical
       > A field eligible for Primary key is called Candidate key
       > Example:
         > Table for RTA
           > VEHICLES
             VEHNO NAME MODEL COST CHASSISNO BRAND
           > Here Candidate keys are VEHNO and CHASSISNO
           > PRIMARY KEY is VEHNO
           > SECOUNDARY KEY is CHASSISNO
       > While creating table SECOUNDARY keys are declared with UNIQUE NOT NULL
    
     > CHECK constraint:
       > Used when rule based on condition
       > Syntax
         > CHECK(condition)
       > Example:
         > SAL must be minium 3000
         > CREATE TABLE EMP33( EMPID INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, SAL MONEY CHECK(SAL>=3000))
         > Testing
           > INSERT INTO EMP33 VALUES (100,'A',1000) gives Error
           > INSERT INTO EMP33 VALUES (101,'B',5000) gives 1 row effected
           > INSERT INTO EMP33 VALUES (102,'C',NULL) gives 1 row effected
           > CHECK constraint allows NULL
         > GENDER must be 'M','F'
           > GENDER CHAR(1) CHECK(GENDER IN ('M','F'))
         > AMT must be multiple of 100
           > AMT MONEY CHECK(AMT%100=0) 
         > PWD must be min 6 characters
           > PWD VARCHAR(12) CHECK(LEN(PWD)>=6) // LEN(<text>) to check length
         > EMAILID must contain '@' and must be ending with '.com' or '.co' or '.in'
           > EMAILID VARCHAR(30) CHECK(EMAILID LIKE '%@%' AND (EMAILID LIKE '%.com' OR EMAILID LIKE '%.co' OR EMAILID LIKE '%.in'))
     
     > FOREIGN key:
       > Used to establish relationship between two talbes
       > To establish relationship between two talbes talbe PRIMARY key of one talbe and add it as 
         FOREIGN key and declare with references constraint
       > Example
         > DEPT
           DNO DNAME LOC
           10  HR    BLR
           20  IT    HYD
           EMP
           EMPID ENAME SAL  DNO REFERENCES DEPT(DNO)
           1     A     5000 10  
           2     B     6000 20
           3     C     4000 90  is invalid 
           4     D     3000 10
           5     E     2000 NULL
       > Values entered in FOREIGN key column should match values if PRIMARY key column
       > FORERIGN Key allows Duolicates and NULLS
       > Afer Declaring FORIEGN key a relatinship is estb between tables called parent/child relationship
       > PRIMARY key table is parent and FOREIGN key table is child
       > Referring table is child amd refferred table in parent
       > Example
          CREATE TABLE DEPT55(DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL, LOC VARCHAR(3) CHECK(LOC IN ('HYD','BLR','MUM','DEL')))
          INSERT INTO DEPT55 VALUES(10,'HR','HYD'),(20,'IT','BLR')
          CREATE TALBE EMP55( EMPID INT PRIMARY KEY, EMANE VARCHAR(10) NOT NULL,SAL MONEY CHECK(SAL>=3000), DNO INT REFERENCES DEPT55(DNO))
          > Testing:
            INSERT INTO EMP55 VALUE(1,'A',5000,10)
            INSERT INTO EMP55 VALUES(2,'B',4000,90)
            INSERT INTO EMP55 VALUES(3,'C',3000,10)
            INSERT INTO EMP55 VALUES(4,'D',4000,NULL)

300523

       > Assignment
         > Create table with given rules
           > ACCOUNTS
             ACCNO  ACTTYPE  balance
           > Rules:
             > Accno should not be dubplicate and null
             > Acttype must be 'S' or 'C'
             > Bal must be min 1000

           > TRANSACTIONS
             TRID TTYPE TDATE TAMT ACCNO
           > Rules
             > TTYPE must be 'W' or 'D'
             > TRID should not be duplicate & null
             > TDATE must be today's date
             > TAMT must ebe multiple of 100
             > ACCNO should match with accounts table accno

    > Relationships types between two tables (parent child)
      ===================
        > One to One (1:1)
        > One to Many (1:m)
        > Many to One (m:1)
        > Many to Many (m:m)

      > By default SQL Server creates One to Many (1:m) relationship between two tables

      > One to One Realtionship (1:1)
        ------------------------
        > To estb between two tables declare foreign key with unique constraint
        > Examples:
          > DEPT 
            DNO DNAME LOC
            10  HR    HYD
            20  IT    BLR
          > MGR
            MGRNO MNAME DNO REFERENCES DEPT(DNO) UNIQUE 
            1     A     10
            2     B     20
          > In the above example one dept is managed by one manger
            and one manager manages exaclty one dept, 
            so relationship between dept and manager is one to one,
            so decalre foreign key with unique constraint.
          
          > CREATE TABLE DEPT ( DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL, LOC VARCHAR(3))
            CREATE TABLE MGR ( MGRNO NUMBER(4) PRIMARY KEY, MNAME VARCHAR(10) NOT NULL, DNO INT REFERENCES DEPT(DNO) UNIQUE)
      
      > Many to Many (m:m) 
        ------------------
        > To estb many to many relationship between two tables create 3rd table
          and in third table take primary keys of both the tables as foreign keys
        > Example:
          > CUST
            CID  NAME  ADDR
            10   A     HYD
            11   B     HYD
            12   C     HYD
          > PRODUCTS
            PRODID  PNAME  PRICE
            100     A       1000
            101     B       2000
            102     C       1500
          > In the above example one cust purchases many products and product purchased by many
            customers, sp relationship between cust & product is many to many, so crete 
            third table and take primary key of both tables ( CID,PRODID) as FOREIGN keys
            > SALES
              DATEID  PRODID  CID  QTY  AMT
              10-     100     10   ?    ?
              10-     100     11   ?    ?
              11-     101     10   ?    ?
            > CREATE TABLE CUST(CID INT PRIMARY KEY, CNAME VARCHAR(10) NOT NULL)
              CREATE TABL E PRODUCTS(PRODID INT PRIMARY KEY,PNAME VARCHAR(10) NOT NULL)
              CREATE TABLE SALES(DATEID INT,PRODID INT REFERENCES PRODUCTS(PRODID),CID INT REFERENCES CUST(CID),QTY INT,AMT MONEY)
             
        > ER DIAGRAM

          ER MODEL     RELATIONAL MODEL

          ENTITIES     TABLES
          ATTRIBUTES   FIELDS
          RELATIONSHIP FOREIGN KEY

          Example: Bank Realtional model for ER Model
           > BANK
             CODE NAME ADDR
           > BRANCH
             BRANCH_ID NAME ADDR CODE(FK)
           > ACCOUNTS
             ACCNO ACTYPE BAL BRANCH_ID(FK)
           > LOANS 
             LOAN_ID LOAD_TYPE AMOUNT BRANCH_ID(FK) CUSTID(FK)
           > CUSTOMERS
             CUSTID NAME PHONE ADDR
        
    > DEFAULT values
      -------
      > A column can be declared with default values as follows
      > While inserting if we skip HIREDATE SQL Server inserts DEFAULT value
      > Example
        > HIREDATE DATE DEFAULT GETDATE()
        > CREATE TABLE EMP44(EMPID INT,ENAME VARCHAR(10),HIREDATE DATE DEFAULT GETDATE())
          INSERT INTO EMP44(EMPID,ENAME) VALUES(100,'A') // here default date is inseted
          INSERT INTO EMP44 VALUES(101,'B','2023-01-01') // here given date is inserted
          INSERT INTO EMP44 VALUES(102,'B',NULL)
          SELECT * FROM EMP44
    
    > TABLE LEVEL
      -----------
      > If constraints are declared after declaring all columns thne it is called table level
      > Syntax
        > CREATE TABLE<tablename>
          (
            COLNAME DATETYPE(SIZE),
            ---------------------,
            ---------------------,
            CONSTRAINT
          )
      > Use TABLE LEVEL for declaring constraints for multiple or combination of columns

    > Declaring check constraints at table level
      ------------------------------------------
      > PRODUCTS
        PRODID PRNAME PRICE MFD_DT      EXP_DT
        100    A      50    2023-05-30  2023-01-01   gives invalid 
        > Rule
          > EXP_DT  > MFD_DT  this must be declared at table level
        > CREATE TABLE PRODUCTS 
         (
          PRODID INT PRIMARY KEY,
          PNAME VARCHAR(10) NOT NULL,
          MFD_DT DATE,
          EXP_DT DATE,
          CHECK (EXP_DT > MFD_DT)
         ) 
         INSERT INTO PRODUCTS VALUES(1,'A',GETDATE(),'2023-01-01') gives error
         INSERT INTO PRODUCTS VALUES(1,'A',GETDATE(),'2023-10-01')

310223

 > Composite Primary key:
   ---------------------
   > In saome tables we may not be able to uniquely identify the records using single column,
     and we need combinations of columns to uniquely identify the records and that combination
     should be declared as Primary Key at table level
   > If combination of columns decalred then it is called Composite Primary key
   > In Composite Primary Key combination should not be dubplicate
   > Example
     > In registrations table SID, CID combinations uniquely identifing the records so declare
       this combination as Primary Key at table level
       > CREATE TABLE STUDENT ( SID INT PRIMARY KEY, SNAME VARCHAR(10) NOT NULL)
         INSERT INTO STUDENT VALUES (1,'A'), (2,'B')
         CREATE TABLE COURSE ( CID INT PRIMARY KEY, CNAME VARCHAR(10) NOT NULL)
         INSERT INTO COURSE VALUES ( 10, '.NET'), (11,'SQL SERVER')
         
         CREATE TABLE REGIESTRATION( SID INT REFERENCES STUDENT(SID), CID INT REFERENCES COURSE(CID), 
         DOR DATE, FEE MONEY, PRIMARY KEY (SID,CID))

         INSERT INTO REGISTRATION VALUES (1,10,GETDATE(),5000)
         INSERT INTO REGISTRATION VALUES (1,11,GETDATE(),5000)
         INSERT INTO REGISTRATION VALUES (2,10,GETDATE(),5000)
         INSERT INTO REGISTRATION VALUES (1,10,GETDATE(),5000) gives Error

     > Assignment 
       > Identify PRimary keys and foreign keys and write create table script
        > CUST                               PRODUCTS
          CID   NAME   ADDR                  PRODID PNAME PRICE
          10                                 100
          11                                 101

          SALES 
          DATEID   PRODID CUSTID  QTY  AMT
          30       100    10      1    2000
          30       101    10      1    1000
          30       101    11      1    2000
          31       100    10      1    2000

 > NOTE: 
   > All constraints can be decalred at table level except NOT NULL
   > A column with UNIQUE constraints can contain NULL value
   > NOT NULL cannot be decalred at Table level
 
 > Adding constraints to existing table
   ------------------------------------
   > 'ALTER' command is used to add constraints to existing table

   > Adding check constraint 
     > Example
       > Adding check constraint with condition sal >= 3000
         > CREATE TABLE EMP88 ( EMPID INT, ENAME VARCHAR(10), SAL MONEY, DNO INT)
         > ALTER TABLE EMP88 ADD CHECK(SAL>=3000)
    > Note 
      > While adding constraint SQL SERVER also validates existing data, if existing date 
        satisfies the condition then constraint is added otherwise not added.
    
 > WITH NOCHECK
   ------------
   > If constraint added with NOCHECK then SQL SERVER will not validate existing date and it validates only
     new data
   > Example
     > ALTER TABLE EMP WITH NOCHECK ADD CHECK(SAL>3000)
 
 > Adding PRIMARY KEY
   ------------------
   > Adding PRIMARY KEY to an exisiting table
   > PRIMARY KEY cannot be added on NULLABLE column // by default all columns are NULLABLE
   > Process
     > Change column to NOT NULL
     > Add PRIMARY KEY 
   > Example:
     > Add PRIMARY KEY to EMPID of EMP88 Table
       > Change column EMPID to NOT NULL
         > ALTER TABLE EMP88 ALTER COLUMN EMPID INT NOT NULL
       > Add PRIMARY KEY
         > ALTER TABLE EMP88 ADD PRIMARY KEY( EMPID )
       > SP_HELP EMP88
 
 > Adding FOREIGN KEY
   ------------------
   > Add FOREIGN KEY to DNO that references DEPT table PRIMARY KEY i.e., DEPTNO
     > CREATE TABLE DEPT
       (DEPTNO INT primary key,
       DNAME VARCHAR(14),
       LOC VARCHAR(13) )

       INSERT INTO DEPT VALUES (10, 'ACCOUNTING', 'NEW YORK')
       INSERT INTO DEPT VALUES (20, 'RESEARCH', 'DALLAS')
       INSERT INTO DEPT VALUES (30, 'SALES', 'CHICAGO')
       INSERT INTO DEPT VALUES (40, 'OPERATIONS', 'BOSTON')

       ALTER TABLE EMP88 
       ADD FOREIGN KEY (DNO) REFERENCES DEPT(DEPTNO)

   > After adding FOREIGN KEY one to many relationship is created
     to establish one to one relationship 
     > Add UNIQUE constraint to DNO
       > ALTER TABLE EMP88 ADD UNIQUE(DNO)

 > Changing from NULL to NOT NULL
   ------------------------------
   > Modify column ENAME to NOT NULL
     > ALTER TABLE EMP88 ALTER COLUMN ENAME VARCHAR(10) NOT NULL

010623

 > DROP constraint
   ---------------
   > Syntax
     > ALTER TABLE <table name> DROP CONSTRAINT <name>
     > Example
       > Drop CHECK constraint in EMP88 table
         > ALTER TABLE EMP88 DROP CONSTRAINT CK__EMP88__SAL__5535A963
       > Drop PRIMARY KEY in DEPT Table
         > ALTER TABLE DEPT DROP CONSTRAINT PK__DEPT__E0EB08D7ACE20F53
   > Note: 
     > PRIMARY KEY constraint camnot be dropped if referenced by some FOREIGN KEY
     > PRIMARY KEY table camnot be dropped if referenced by some FOREIGN KEY
     > PRIMARY KEY table camnot be truncated if referenced by some FOREIGN KEY
 
 > DELETE rules
   ------------
   > ON DELETE NO ACTION (DEFAULT)
   > ON DELETE CASCADE 
   > ON DELETE SET NULL
   > ON DELETE SET DEFAULT
   
   > These rules are decalred with FOREIGN KEY
   > Above rile specifies how child rows are affected if parent rows are deleted

   > ON DELETE NO ACTION 
     > Parent rows cannot be deleted if associatedwith child rows
     > Example
      > CREATE TABLE DEPT66 (DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL)
        INSERT INTO DEPT66 VALUES(10,'HR'), (20,'IT')
        CREATE TABLE EMP66 ( EMPNO INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, DNO INT REFERENCES DEPT66(DNO))
        INSERT INTO EMP66 VALUES(1,'A',10),(2,'B',10)
        DELETE FROM DEPT66 WHERE DNO=10 gives Error
      > Scenario
        > ACCOUNTS
          ACCNO    BAL
          100      100004
          101      200000

          LOANS 
          ID  TYPE AMT  ACCNO REFERENCES
          1   H    30   100
          2   C    10   100
          > Note
            > Account closing is not possible if associated with loans
   
   > ON DELETE CASCADE
     > If parent row is deleted then it is deleted along with child rows
     > Example
       > CREATE TABLE DEPT66 (DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL)
        INSERT INTO DEPT66 VALUES(10,'HR'), (20,'IT')
        CREATE TABLE EMP66 ( EMPNO INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, DNO INT REFERENCES DEPT66(DNO) ON DELETE CASCADE)
        INSERT INTO EMP66 VALUES(1,'A',10),(2,'B',10)
     > Scenario
       > ACCOUNTS 
         ACCNO  BAL
         100    10000

         TRANSACTIONS
         TRID  TTYPE TDATE TAMT ACCNO  REFERENCES ACCOUNTS(ACCNO)
         1     W     ?     2000 100    ON DELETE CASCADE
         2     D     ?     1000 100
        > NOTE
          > When account is closed, along with account delete transactions
   
   > ON DELETE SET NULL
     > If Parent row is deleted then child are not deleted but FOREIGN KEYS are set to null value
     > Example
       > CREATE TABLE DEPT66 (DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL)
        INSERT INTO DEPT66 VALUES(10,'HR'), (20,'IT')
        CREATE TABLE EMP66 ( EMPNO INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, DNO INT REFERENCES DEPT66(DNO) ON DELETE SET NULL)
        INSERT INTO EMP66 VALUES(1,'A',10),(2,'B',10)
        > Testing
          > DELETE FROM DEPT66 WHERE DNO = 10 gives one row affected
            SELECT * FROM EMP66
            EMPNO  ENAME  DNO
            1       A      NULL
            2       B      NULL
       > Scenario
         > PROJECTS
           PROID  NAME   DURATION   COST   CLIENT
           100    A      5 YEARS    500    TATA MOTORS

           EMP
           EMPID  ENAME  SAL  PROID  REFERENCES PROJECTS(PROID)
           1      ....   ...  100    ON DELETE SET NULL
           2      ....   ...  101
           > NOTE 
             > If project is completed set employee's PROID to null
  
   > ON DELETE SET DEFAULT
     > If Parent row is deleted then childs are not deleted but FOREIGN KEY is set to default value
     > Example
       > REATE TABLE DEPT66 (DNO INT PRIMARY KEY, DNAME VARCHAR(10) UNIQUE NOT NULL)
        INSERT INTO DEPT66 VALUES(10,'HR'), (20,'IT')
        CREATE TABLE EMP66 ( EMPNO INT PRIMARY KEY, ENAME VARCHAR(10) NOT NULL, DNO INT DEFAULT 20 REFERENCES DEPT66(DNO) ON DELETE SET DEFAULT)
        INSERT INTO EMP66 VALUES(1,'A',10),(2,'B',10)
        DELETE FROM DEPT66 WHERE DNO=10 gives 1 row effected
        SELECT * FROM EMP66
        EMPNO ENAME DNO
        1     A     20
        2     B     20

 > Summery:
   > Importance of constraints
   > Types of constraints
   > DEcalreing constraints
     > Column level
     > Table level
   > Adding constraints to existing table
   > Delete rules

 > JOINS
  =====
   > JOIN is an operation performed to get data from two or more tables
   > In DB related data may be stored in multiple tables, to gather or to combine
    data stored in multiple tables we need to join those tables
   > Example
     > ORDER talbe and CUSTOMER table joining
   > Types of JOINS
     > INNER JOIN / EQUI JOIN
     > OUTER JOIN
       > LEFT JOI
       > RIGHT JOIN
       > FULL JOIN
     > NON EQUI JOIN
     > SELFT JOIN
     > CROSS JOIN / CARTESIAN JOIN 
    
020623

   > INNER JOIN/EQUI JOIN
     > To perform INNER JOIN between two tables, there must be a common field, name of 
       the commong field need not be same and PRIMARY KEY FOREIGN KEY relationship is 
       not compulsory
     > EQUI JOIN is performed based on the common field with same data type
     > Syntax
       > SELECT column FROM table1 INNER JOIN table2 ON join condition
     > JOIN Condition
       --------------
       > SQL Server join the records of two tables based on given join condition
         > If condition is true records are joined and if false records are not joined
       > Syntax
         > TABLE1.<commonfield> = TABLE2.<commonfield>
       > Example
         > EMP 
           EMPNO  ENAME SAL   DEPTNO
           1      A     5000  10
           2      B     3000  20
           3      C     4000  30
           4      D     2000  40
           5      E     3000  50
         > DEPT 
           DEPTNO DNAME      LOC
           10     ACCOUNTS   NY
           20     RESEARCH   NY
           30     SALES      NY
           40     OPERATIONS NY
         > Display ENAME SAL DNAME LOC
                  ---------- ---------
                     EMP       DEPT
            > SELECT ENAME, SAL, DNAME, LOC FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO
              > A  5000 ACCOUNTS NY
                B  3000 RESEARCH NY
                C  4000 SALES    NY
                D  2000 RESEARCH NY
            > SELECT EMP.ENAME, EMP.SAL, DEPT.DNAME, DEPT.LOC FROM EMP INNER JOIN DEPT ON EMP.DEPTNO = DEPT.DEPTNO // mentioning table like EMP. DEPT. after SELECT makes it faster to execute
            > SELECT E.ENAME, E.SAL, D.DEPTNO, D.DNAME, D.LOC FROM EMP AS E INNER JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO
            > NOTE
              > In join querries decalre table alias and prefix column names with talbe alias for two reasons
                > To avoid ambiguity error
                > for faster execution
              > 
            > Example
              > Display employee details with dept details working at New York location
                > SELECT E>ENAME, D.DNAME, D.LOC FROM EMP AS E INNER JOIN DEPT D ON E.DEPTNO = D>DEPTNO WHERE D.LOC = 'NY'
              > Display order details with custom details
                > SELECT O.*, C.* FROM ORDERS AS O INNSER JOIN CUST AS C ON O.CID = C.CID
              > Display order details with custom details to be delivered today
                > SELECT O.*, C.* FROM ORDERS AS O INNSER JOIN CUST AS C ON O.CID = C.CID
                  WHERE O.DEL_DT = GETDATE()
      
      > Joining more than two table
       -----------------------------
        > Number of join conditions also increase with numbre of talbes
        > To join N talbes N-1 join conditions required
        > syntax
          > SELECT column FROM table1 INNER JOIN table2 ON join condition INNER JOIN table3 ON join condition INNER JOIN table4 ON join condition INNER JOIN table5 ON join condition...
        > Example
          > EMP      DEPT     LOCAITONS    COUNTRIES
            EMPNO    DEPTNO   LOCID        COUNTRY_ID
            ENAME    DNAME    CITY         COUNTRY_NAME
            SAL      LOCID    STATE
            DEPTNO            COUNTRY_ID
            > Display ENAME DNAME CITY STATE COUNTRY_NAME
              > SELECT E.ENAME, 
                       D.DNAME,
                       L.CITY,L.STATE,
                       C.COUNTRY_NAME
                FROM EMP AS E INNER JOIN DEPT AS D 
                       ON E>DEPTNO = D.DEPTNO
                                INNER JOIN LOCATIONS AS L
                       ON D.LOCID = L.LOCID
                                INNER JOIN COUNTRIES AS C 
                       ON L.COUNTRY_ID = C.COUNTRY_ID
    
    > OUTER JOIN
      ----------
      > Inner jkoin returns only matching records , to display unmatched records preform outer join
      > Outer Join is of 3 types
        > LEFT JOIN
        > RIGHT JOIN
        > FULL JOIN

030623

      > LEFT JOIN
        > Returns all rows ( matched + unmatched ) from left side table and matching rows fro mright side table
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E LEFT JOIN  DEPT AS D ON E.DEPTNO = D.DEPTNO
        > Returns all rows from EMP table and matching rows from dept table
          A ACCOUNTS
          B RESEARCH
          C SALES
          D RESEARCH
          E NULL => unmatched rows from EMP
      
      > RIGHT JOIN
        > Returns all rows from right side table matching rows from left side table
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E RIGHT JOIN  DEPT AS D ON E.DEPTNO = D.DEPTNO
            A ACCOUNTS
            B RESEARCH
            C SALES
            D RESEARCH
            NULL OPERATIONS => Unmatched from dept

      > FULL JOIN
        > Returns all the rows from both the tables
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E FULL JOIN  DEPT AS D ON E.DEPTNO = D.DEPTNO
            A ACCOUNTS
            B RESEARCH
            C SALES 
            D RESEARCH
            E NULL  => unmatched from EMP
            NULL OPERATIONS => unmatched from DEPT
    
    > Display Unmatched records:
      --------------------------
      > Left side table
        > syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS LEFT JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO WHERE D.DNAME IS NULL
            E NULL
      > Right side table
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E RIGHT JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO WHERE E.ENAME IS NULL
            NULL OPERATIONS
      > Both the tables
        > Syntax
          > SELECT E.ENAME, D.DNAME FROM EMP AS E FULL JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO WHERE D.DNAME IS NULL OR E.ENANE IS NULL
      
      > Scenario:
        > EMP                       PROJECTS
          EMPID ENAME SAL PROJID    PROJID  NAME DURATION COST CLIENT
          1               100       100
          2               101       101
          3               NULL      102
        > Display employee details with project details
        > Display employee details woth project details and also display employee not assigned to any project
        > Display employee details woth project details and also display projects where no employee assignes to it

 > NON EQUI JOIN
   -------------
   > NON EQUI JOIN is performed between the tables not sharing a common field
   > Example
      > EMP                          SALGRADE
         EMPNO  ENAME  SAL            GRADE  LOSAL  HISAL
         1      A      3000           1      700    1000
         2      B      1500           2      1001   2000
         3      C      2000           3      2001   3000
         4      D      1000           4      3001   4000
         5      E      4000           5      4001   9999
         > Display ENAME SAL     GRADE
                  ---------     -----
                    EMP        SALGRADE
          SELECT E.ENAME, E.SAL, S.GRADE FROM EMP AS E JOIN  SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL 
           A  3000 3 
           B  1500 2
           C  2000 2
           D  1000 1
           E  4000 4
      > Display grade 4 employee list
        > SELECT E.ENAME, E.SAL, S.GRADE FROM EMP AS E JOIN  SALGRADE S ON E.SAL BETWEEN S.LOSAL AND S.HISAL WHERE S.GRADE = 4         
      > Display ENAME DNAME GRADE ( data belongs to 3 tables EMP DEPT SALGRADE)
        > EMP DEPT INNER JOIN and EMP SALGRADE NON EQUI JOIN
        > SELECT E.ENAME, D.DNAME, S.GRADE FROM EMP AS E INNER JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO JOIN SALGRADE AS S ON E.SAL BETWEEN S.LOSAL AND S.HISAL
          > Steps
            EMP                              SALGRADE
            EMPNO ENAME SAL   DEPTNO         GRADE     LOSAL    HISAL
            1     A     3000  10             1         700      1000
            2     B     1000  20             2         1001     2000
            3     C     4000  30             3         2001     3000
                                             4         3001     4000
            Output is joined with DEPT Table       DEPT
            1 A 3000 3  10                          DEPTNO  DNAME     LOC
            2 B 1000 1  20                          10      ACCOUNTS   
            3 C 4000 4  30                          20      RESEARCH

            Output ( ON E.DPETNO = D.DEPTNO )
            1 A 3000 3 10 accounts
            2 B 1000 1 20 RESEARCH
            3 C 4000 4 30 SALES

            SELECT E.ENANME, D.DNAME, S.GRADE
            A ACCOUNTS 3
            B RESEARCH 1
            C SALES    4

050623

 > SELF JOIN
   ---------
   > Joining a table to itself
   > In self join a record of the table joined with another record of itlsef
   > To perform SELF JOIN the same table should be declared with different alias
   > Syntax
     > FROM EMP AS X JOIN AS Y // same table with different alias
   > Example
     > Display ENAME MGRNAME  
        EMP X                   EMP Y
        EMPNO ENAME MGR         EMPNO ENAME MGR
        1     A     NULL        1     A     NULL
        2     B     1           2     B     1
        3     C     1           3     C     1
        4     D     2           4     D     2
        5     E     3           5     E     3
      > SELECT X.ENAME, Y.ENAME AS MANAGER FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO
        B A
        C A
        D B
        E C
     > Display Emplouyees reporting to blake
       > SELECT X.ENAME, Y.ENAME AS MANAGER FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO WHERE Y.ENAME = 'BLAKE'
     > Display Blake's manager name
       > SELECT X.ENAME, Y.ENAME AS MANAGER FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO WHERE X.ENAME = 'BLAKE'
     > Display Emplouyees earning more than their managers
       > SELECT X.ENAME, X.SAL, Y.ENAME AS MGR, Y.SAL AS MGRSAL FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO WHERE X.SAL > Y.SAL
     > Display employees joined before their manager
       > SELECT X.ENAME, X.HIREDATE, Y.ENAME AS MGR, Y.HIREDATE FROM EMP AS X JOIN EMP AS Y ON X.MGR = Y.EMPNO WHERE X.HIREDATE < Y.HIREDATE
     > Question
       > TEAMS 
         ID  COUNTRY
         1   IND
         2   AUS
         3   ENG
         > Write a querry to display
           IND VS AUS
           IND VS ENG
           IND VS ENG
           TEAMS A      TEAMS B
           ID COUNTRY  ID COUNTRY
           1  IND      1  IND
           2  AUS      2  AUS
           3  ENG      3  ENG
           > CREATE TABLE TEAMS( ID INT, COUNTRY VARCHAR(3))
           > SELECT A.COUNTRY + ' VS ' + B.COUNTRY FROM TEAMS AS A JOIN TEAMS AS B ON A.ID < B.ID
       > Assignmet
         > Display employees earnign same salary
         > Display employees joined on smae day
 
 > CROSS JOIN / CARTESIAN JOIN
   ---------------------------
   > Returns cross product or cartesian product of two tables
   > like
     A = 1,2,
     B = 3,4,
     AXB = (1,3) (1,4) (2,3) (2,4)
   > If cross join preformed between two talbes all the records of first table will be joined with all the records of 2nd table
   > To perform CROSS JOIN JOIN Querry is not required
   > Example
     > SELECT E.ENAME, D.DNAME FROM EMP AS E JOIN DEPT AS D
 
 > JOIN & GROUP BY
   ---------------
   > SELECT D.DNAME, SU<(E.SAL) AS TOTSAL FROM EMP AS E INNER JOIN DEPT AS D ON E.DEPTNO = D.DEPTNO GROUP BY D.DNAME

060623

 > SET OPERATIONS
   --------------
   > UNION 
   > UNION ALL
   > INTERSECT 
   > EXCEPT
   > Explaination
     A = 1,2,3,4
     B = 1,2,5,6
     A UNION B = 1,2,3,4,5,6
     A UNION ALL B = 1,2,3,4,5,6
     A INTERSECT B = 1,2
     A EXCEPT B = 3,4
     B EXCEPT A = 5,6
   > IN SQL Server SET OPERATIONS performed between records ( rows ) return by two querries
   > Syntax:
     > SELECT statement 1 UNION / UNION ALL / INTERSET / MINUS SELECT statement 2
   > Rules
     > No of columns return by both querries must be same
     > Correspoinding columns datatype must be same
   > Example
     > SELECT JOB FROM EMP WHERE DEPT = 30

   > UNION
     > Comnines rows return by tow querries
     > Duplicates are eliminated
     > Result is sorted
     > Syntax
       > SELECT JOB FROM EMO WHERE DEPT = 20
         UNION
         SELECT JOB FROM EMO WHERE DEPT = 30
         > ANALYST
           CLERK
           MANAGER
           SALESMAN

   > UNION VS JOIN
     > UNION comnines rows , JOIN combines columns
     > UNION is horizontal merge, JOIN is vertical merge
     > UNION performed between tow similar structures, JOIN is performed between tow dissimilar structures
     > Example
       > T1 T2
         F1 C1
         1  10
         2  20
         3  30
         > T1 U T2   T1 JOIN T2
           1         1       10
           2         2       20
           3         3       30
           10
           20
           30
       > Scenario
         > EMP_US
           ENO ENAME SAL DNO
           EMP_IND
           ENO ENAME SAL DNO
           DEPT 
           DNO DNAME LOC
           > Display total empleyee list
             > SELECT * FROM EMP_US UNION SELECT * FROM EMP_IND
           > Display employees working at US loc with dept details
             > SELECT E.*, D.* FROM EMP_US AS E INNER JOIN DEPT AS D ON E.DNO = D.DNO
           > Display total employees with dept details
             > SELECT E.*, D.* FROM EMP_US AS E INNER JOIN DEPT AS D ON E.DNO = D.DNO 
               UNION
               SELECT E.*, D.* FROM EMP_IND AS E INNER JOIN DEPT AS D ON E.DNO = D.DNO
   
   > UNION ALL
     > Combines rows
     > Duplicates are not eleminated
     > Result is not sorted
     > Example
       > SELECT JOB FROM EMP WHERE DEPT = 20
         UNION ALL
         SELECT JOB FROM EMP WHERE DEPT = 30

     > UNION vs UNION ALL
       > UNION eleminates duplicates, UNION ALL doesn't
       > UNION sort resukts, UNION ALL doesn't
       > UNION is slower, UNION ALL is faster
   
   > INTERSECT
     > Returns common values from the output of two select statements
     > Example
       > SELECT JOB FROM EMP WHERE DEPT = 20
         INTERSECT 
         SELECT JOB FROM EMP WHERE DEPT = 30
         > CLERK
           MANAGER
   
   > EXCEPT
     > Returns values present in 1st querry output not present in 2nd querry output
     > Example
       > SELECT JOB FROM EMP WHERE DEPT = 20
         EXCEPT
         SELECT JOB FROM EMP WHERE DEPT = 30
         > ANALYST
       > SELECT JOB FROM EMP WHERE DEPT = 30
         EXCEPT
         SELECT JOB FROM EMP WHERE DEPT = 20

 > Question
   > T1 T2
     F1 C1
     1  1
     2  2
     3  3
     10 40
     20 50
     30 60
     > Write outpur from the following operations
      > INNER JOIN
       > LEFT JOIN
      > RIGHT JOIN
       > FULL JOIN
       > UNION
       > UNION ALL
       > INTERSECT
       > EXCEPT
 
 // Google SQL ONLINE Compilers. visit hacker rank for complex querries

070623

 > SUBQUERIES
   ----------
   > Also called NESTED QUERIES
   > A Querry in another querry is called subquery or nested query
   > There is inner/child/sub querry and outer/parent/main query
   > First inner qurry is executed and then outer
   > Outer of inner query is incput to outer qurry
   > Use Subqueries when where condition based on unknown value
   > Types of subquerries
     > Single row
     > Multi row
     > Co-related 
     > Derived
     > Scalar

   > Single row subquery
     > If subquerry returns one row 
     > Syntax
       > SELECT colname FROM tabname WHERE colname OP (SELECT STATEMENT)
       > Operator must be any relational operator like = > >= < <= <>
     > Example
       > Display empleyees earning more than Blake
         > SELECT * FROM EMP WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'BLAKE')
       > Display empleyees who are senior to king
         > SELECT * FROM EMP WHERE HIREDATE < ( SELECT HIREDATE FROM EMP WHERE ENAME = 'KING')
       > Display name of the empleyee earning max sal
         > SELECT * FROM EMP WHERE SAL = MAX(SAL) gives error
         > SELECT * FROM EMP WHERE SAL = ( SELECT MAX(SAL) FROM EMP)
       > Find the name of the empleyee who's having maximum experience
         > SELECT * FROM EMP WHERE HIREDATE = ( SELECT MIN(HIREDATE) FROM EMP)
       > Display 2nd max salary
         > SELECT MAX(SAL) FROM EMP WHERE SAL < ( SELECT MAX(SAL) FROM EMP)
       > Display name of employee earning 2nd max salary
         > SELECT ENAME FROM EMP WHERE SAL = ( SELECT MAX(SAL) FROM EMP WHERE SAL < (SELECT MAX(SAL) FROM EMP))
         (57:34)

080623
 
 > MULTI-SUBQUERRY
   --------------
   > If a subquerry returns more than one row then it is called multi-row subquerry
   > Syntax
     > SELECT columns FROM tabname WHERE colname OP ( SELECT STATEMENT)
     > OP must be IN, NOT IN, ANY, ALL
   > Example
     > Display employees working at NEW YORK, CHICAGO locations
       > SELECT * FROM EMP WHERE DEPTNO = ( SELECT DEPTNO FROM DEPT WHERE LOC IN ('NEW YORK', 'CHOCAGO'))

   > ANY 
     > Use ANY operator for > < comparision with multiple values
       > WHERE X > ANY ( 1000, 2000, 3000)
         IF X = 800 FALSE
                1500  TRUE
                4500  TRUE
       > WHERE X < ANY ( 1000, 2000, 3000)
         IF X = 800 TRUE
                1500  TRUE
                4500  FALSE
   > ALL
     > Use ALL operator for > < comparision with multiple values
       > WHERE X > ALL ( 1000, 2000, 3000)
         IF X = 800  FALSE
                1500  FALSE
                4500  TRUE
       > WHERE X < ALL ( 1000, 2000, 3000)
         IF X = 800  TRUE
                1500  FALSE
                4500  FALSE
   
   > Example
     > Display empleyees earning more than all managers
       > SELECT SAL FROM EMP WHERE SAL > ANY ( SELECT SAL FROM EMP WHERE JOB = 'MANAGER' )
     > Display employees earning more than at least one manager
       > SELECT * FROM EMP WHERE SAL > ANY ( SELECT SAL FROM EMP WHERE JOB = 'MANAGER' )
 
 > CO-RELATED subqueries
   ---------------------
   > If inner query referecnces values of outer query then it is called CO-RELATED subquery
   > In CO-RELATED subquery execution starts from outer query and inner query execution 
     depends on number rows returned by outer query
   > Use CO-RELATED subquery to execute subquery for each row return by outer query
   > Example
     > EMP 
       EMPNO ENAME SAL  DEPTNO
       1     A     3000 10
       2     B     5000 20
       3     c     4000 30
       4     D     6000 10
       5     E     3000 20
       > Display empleyees earning more than avg(SAL) of their dept
         > SELECT * FROM EMP AS X WHERE SAL > ( SELECT AVG(SAL) FROM EMP WHERE DEPTNO = X.DEPTNO )
         1 A 3000 10 3000>(4500) FALSE
         2 B 5000 20 5000>(4000) TRUE
         3 C 4000 30 4000>(4000) FALSE
         4 D 6000 10 6000>(4500) TRUE
         5 E 3000 20 3000>(4500) FALSE
       > Display employees earning max salaries in their department
         > SELECT * FROM EMP AS X WHERE SAL = ( SELECT MAX(SAL) FROM EMP WHERE DEPTNO = X.DEPTNO )
         1 A 3000 10 3000 = (6000) FALSE
         2 B 5000 20 5000 = (5000) TRUE
         3 C 4000 30 4000 = (4000) TRUE
         4 D 6000 10 6000 = (6000) TRUE
         5 E 3000 20 3000 = (6000) FALSE

       > Display top 3 max salaries
         EMPA  EMPB
         SAL   SAL
         5000  5000 3>(0) TRUE
         1000  1000 3>(4) FALSE
         3000  3000 3>(2) TRUE
         2000  2000 3>(3) FALSE
         4000  4000 3>(1) TRUE
         > SELECT DISTINCT A.SAL FROME EMP AS A WHERE 3 > ( SELECT COUNT (B.SAL) FROM EMP AS B WHERE A.SAL < B.SAL) ORDER BY SAL DESC // DISTINCT to eleminate duolicates

090623

 > DERIVED TABLES
   --------------
   > Subqueries in FROM clause are called derived tables
   > Syntax
     > SELECT columns FROM ( SELECT STATEMENT ) AS <alias> [WHERE COND]
     > Here subquery output acts like a table for outer query
   > Derived tables are used in following scenarios
     > To control order of execution of a clauses
       > Default order of SQL Server FROM WHERE GROUP BY HAVING SELECT ORDER BY
       > Example
         > Display rank of employees based on sal
           > SELECT ENAME, SAL, DENSE_RANK() OVER (ORDER BY SAL DESC) AS RANK FROM EMP gives ranks of all the empleyees,
             but to display TOP 5 empleyees
           > SELECT ENAME, SAL, DENSE_RANK() OVER (ORDER BY SAL DESC) AS RANK FROM EMP WHERE RANK <= 5 gives error as
             Alias cannot be used in where clause because where clause is executed before SELECT
           > To overcome this problem first execute SELECT then execute WHERE, use DERIVED TABLE
           > SELECT DISTINCT SAL FROM ( SELECT ENAME, SAL, DENSE_RANK() OVER (ORDER BY SAL DESC) AS RANK FROM EMP) AS E WHERE RANK <= 5 ORDER BY SAL DESC
         > SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER ( ORDER BY EMPNO ASC ) AS RNO FROM EMP
           > The above query returns all the records with record number
           > To display first 5 rows
             SELECT * FROM (SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER ( ORDER BY EMPNO ASC ) AS RNO FROM EMP ) AS E WHERE RNO <= 5
             > Also different condions you can write
               > WHERE RNO IN ( 5,7,11 )
                 WHERE RNO BETWEEN 5 AND 10
                 WHERE RNO %2 = 0
           > Display last 3 rows
             > SELECT * FROM (SELECT EMPNO, ENAME, SAL, ROW_NUMBER() OVER ( ORDER BY EMPNO ASC ) AS RNO FROM EMP ) AS E WHERE RNO >= ( SELECT COUNT (*) -2 FROM EMP )
     > To use result of one operation in another operation
     > To join query outputs
     